using Google.Protobuf.Reflection;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using Newtonsoft.Json;
using ProtoBuf.Reflection;
using ProtoBuf.Reflection.Internal;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace ProtoBuf.Schemas
{
    [Trait("kind", "schema")]
    public class SchemaTests
    {
        private readonly ITestOutputHelper _output;

        private const string SchemaPath = "Schemas";
        public static IEnumerable<object[]> GetSchemas()
        {
            foreach (var file in Directory.GetFiles(SchemaPath, "*.proto", SearchOption.AllDirectories))
            {
                yield return new object[] { Regex.Replace(file.Replace('\\', '/'), "^Schemas/", ""), false };
                //if (file.IndexOf("issue864", StringComparison.InvariantCultureIgnoreCase) >= 0)
                {
                    yield return new object[] { Regex.Replace(file.Replace('\\', '/'), "^Schemas/", ""), true };
                }
            }
        }

        [Fact]
        public void CanWriteMessageSetData()
        {
#pragma warning disable CS0618
            using var ms = new MemoryStream();
            using (var state = ProtoWriter.State.Create(ms, null, null))
            {
                state.WriteFieldHeader(5, WireType.String);
                var tok = state.StartSubItem(null);

                state.WriteFieldHeader(1, WireType.StartGroup);
                var tok2 = state.StartSubItem(null);

                state.WriteFieldHeader(2, WireType.Varint);
                state.WriteInt32(15447542);

                state.WriteFieldHeader(3, WireType.String);
                var tok3 = state.StartSubItem(null);

                state.WriteFieldHeader(1, WireType.String);
                state.WriteString("EmbeddedMessageSetElement");

                state.EndSubItem(tok3);
                state.EndSubItem(tok2);

                state.EndSubItem(tok);

                state.Close();
#pragma warning restore CS0618
            }

            var hex = BitConverter.ToString(ms.ToArray(), 0, (int)ms.Length);
            Assert.Equal("2A-24-0B-10-F6-EB-AE-07-1A-1B-0A-19"
                       + "-45-6D-62-65-64-64-65-64-4D-65-73-73-61-67-65-53"
                       + "-65-74-45-6C-65-6D-65-6E-74-0C", hex);
        }

        

        [Fact]
        public void BasicCompileClientWorks()
        {
            var result = CSharpCodeGenerator.Default.Compile(new CodeFile("my.proto", "syntax=\"proto3\"; message Foo {}"));
            Assert.Empty(result.Errors);
            Assert.StartsWith("// <auto-generated>", result.Files.Single().Text);
        }

        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore };

        [Fact]
        public void FieldTypes()
        {
            var schemaPath = Path.Combine(Directory.GetCurrentDirectory(), SchemaPath);
            const string path = "field_types.proto";

            var set = new FileDescriptorSet();
            set.Add(path, includeInOutput: true);
            set.Process();
            foreach (var file in set.Files)
            {
                foreach (var messageType in file.MessageTypes)
                {
                    foreach (var field in messageType.Fields)
                    {
                        if (field.Name.Equals("field1"))
                        {
                            Assert.Equal("Foo", field.GetEnumType().Name);
                        }
                        else if (field.Name.Equals("field2"))
                        {
                            Assert.Equal("TestObject", field.GetMessageType().Name);
                        }
                    }
                }
            }
        }

        [Fact]
        public void FullyQualifiedNames()
        {
            var schemaPath = Path.Combine(Directory.GetCurrentDirectory(), SchemaPath);
            const string path = "field_types.proto";

            var set = new FileDescriptorSet();
            set.Add(path, includeInOutput: true);
            set.Process();
            foreach (var file in set.Files)
            {
                foreach (var messageType in file.MessageTypes)
                {
                    if (messageType.Name.Equals("TestObject"))
                    {
                        Assert.Equal("example.TestObject", messageType.GetFullyQualifiedName());
                    }

                    foreach (var nestedType in messageType.NestedTypes)
                    {
                        if (nestedType.Name.Equals("NestedObject"))
                        {
                            Assert.Equal("example.TestObject.NestedObject", nestedType.GetFullyQualifiedName());
                        }
                    }

                    foreach (var nestedEnum in messageType.EnumTypes)
                    {
                        if (nestedEnum.Name.Equals("NestedEnum"))
                        {
                            Assert.Equal("example.TestObject.NestedEnum", nestedEnum.GetFullyQualifiedName());
                        }
                    }
                }
            }
        }

        [SkippableFact]
        public void EverythingProtoLangver3()
        {
            Skip.IfNot(RuntimeInformation.IsOSPlatform(OSPlatform.Windows));
            var schemaPath = Path.Combine(Directory.GetCurrentDirectory(), SchemaPath);
            const string path = "everything.proto";

            var set = new FileDescriptorSet();
            set.AddImportPath(schemaPath);
            set.Add(path, includeInOutput: true);
            set.Process();
            var langver = set.Files[0].Options.GetOptions()?.CSharpLanguageVersion;
            Assert.Equal("3", langver);

            var sourceFiles = CSharpCodeGenerator.Default.Generate(set).Select(x => x.Text).ToArray();
            Assert.Single(sourceFiles);
            _output.WriteLine(sourceFiles[0]);
            using var csharp = new CSharpCodeProvider(new Dictionary<string, string>
            {
                // { "CompilerVersion", "v3.5"}
            });
            var p = new CompilerParameters
            {
                GenerateInMemory = true
            };
            p.ReferencedAssemblies.Add(typeof(ProtoContractAttribute).Assembly.Location); // add protobuf-net reference
            p.ReferencedAssemblies.Add("System.dll"); // for [DefaultValue]
            p.ReferencedAssemblies.Add("System.Core.dll"); // for extension methods
            try
            {
                var results = csharp.CompileAssemblyFromSource(p, sourceFiles);
                var count = results.Errors.Count;
                Assert.Equal(3, count);
                foreach (CompilerError error in results.Errors)
                {
                    Assert.Equal("CS0619", error.ErrorNumber);
                    var txt = error.ErrorText;
                    bool expected = txt.StartsWith("'ProtoBuf.ProtoMemberAttribute.AsReference' is obsolete")
                        || txt.StartsWith("'ProtoBuf.ProtoMemberAttribute.DynamicType' is obsolete");
                    Assert.True(expected);
                }
            }
            catch (PlatformNotSupportedException) { }
        }

        [SkippableFact()]
        public void DescriptorProtoVB()
        {
            Skip.IfNot(RuntimeInformation.IsOSPlatform(OSPlatform.Windows));
            var schemaPath = Path.Combine(Directory.GetCurrentDirectory(), SchemaPath);
            const string path = "descriptor.proto";

            var set = new FileDescriptorSet();
            set.AddImportPath(schemaPath);
            set.Add(path, includeInOutput: true);
            set.Process();

            var options = new Dictionary<string, string>
            {
                ["langver"] = "9",
            };

#pragma warning disable CS0618
            var sourceFiles = VBCodeGenerator.Default.Generate(set, options: options).Select(x => x.Text).ToArray();
#pragma warning restore CS0618
            Assert.Single(sourceFiles);
            _output.WriteLine(sourceFiles[0]);
            using var vb = new VBCodeProvider(new Dictionary<string, string>
            {
                // { "CompilerVersion", "v3.5"}
            });
            var p = new CompilerParameters
            {
                GenerateInMemory = true
            };
            p.ReferencedAssemblies.Add(typeof(ProtoContractAttribute).Assembly.Location); // add protobuf-net reference
            p.ReferencedAssemblies.Add("System.dll"); // for [DefaultValue]
            p.ReferencedAssemblies.Add("System.Core.dll"); // for extension methods

            try
            {
                var results = vb.CompileAssemblyFromSource(p, sourceFiles);
                Assert.Empty(results.Errors);
            }
            catch (PlatformNotSupportedException) { }
        }

        [Fact]
        public void LargeDefaultValueIsCorrect()
        {
            var schemaPath = Path.Combine(Directory.GetCurrentDirectory(), SchemaPath);
            const string path = "bigIntegerDefaultValue.proto";

            var set = new FileDescriptorSet();
            set.AddImportPath(schemaPath);
            set.Add(path, includeInOutput: true);
            set.Process();
            var langver = set.Files[0].Options.GetOptions()?.CSharpLanguageVersion;
            Assert.Equal("3", langver);

            var sourceFiles = CSharpCodeGenerator.Default.Generate(set).Select(x => x.Text).ToArray();
            Assert.Single(sourceFiles);
            _output.WriteLine(sourceFiles[0]);

            using var csharp = new CSharpCodeProvider(new Dictionary<string, string>
            {
                // { "CompilerVersion", "v3.5"}
            });
            var p = new CompilerParameters
            {
                GenerateInMemory = true
            };

            p.ReferencedAssemblies.Add(typeof(ProtoContractAttribute).Assembly.Location); // add protobuf-net reference
            p.ReferencedAssemblies.Add("System.dll"); // for [DefaultValue]
            p.ReferencedAssemblies.Add("System.Core.dll"); // for extension methods

            CompilerResults results;
            try
            {
                results = csharp.CompileAssemblyFromSource(p, sourceFiles);
                Assert.Empty(results.Errors);
            }
            catch (PlatformNotSupportedException)
            {
                return;
            }

            var assembly = results.CompiledAssembly;
            var messageType = assembly.GetType("TestMessage");

            var properties = messageType.GetProperties();
            Assert.Equal(2, properties.Length);

            foreach (var property in properties)
            {
                var defaultValueAttribute = (DefaultValueAttribute)Attribute.GetCustomAttribute(property, typeof(DefaultValueAttribute));
                Assert.NotNull(defaultValueAttribute);
                Assert.Equal(typeof(ulong), defaultValueAttribute.Value.GetType());
                Assert.Equal(18446744073709551615UL, defaultValueAttribute.Value);
            }
        }

        [Theory]
        [MemberData(nameof(GetSchemas))]
        public async Task CompareProtoToParser(string path, bool includeImports)
        {
            if (path == "google/protobuf/map_unittest_proto3.proto") return; // TODO known oddity

            var schemaPath = Path.Combine(Directory.GetCurrentDirectory(), SchemaPath);
            _output.WriteLine(Path.GetDirectoryName(
                Path.Combine(schemaPath, path).Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar)));

            bool includeComments = IncludeComments(path);

            var protocBinPath = Path.Combine(schemaPath, Path.ChangeExtension(path, "protoc.bin"));
            int exitCode;
            string protocExe = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? @"windows\protoc" :
                RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? @"macosx/protoc" : "";
            if (string.IsNullOrWhiteSpace(protocExe))
                throw new PlatformNotSupportedException(RuntimeInformation.OSDescription);
            using (var proc = new Process())
            {
                var psi = proc.StartInfo;
                psi.FileName = protocExe;

                psi.Arguments = $"--experimental_allow_proto3_optional --descriptor_set_out={protocBinPath} {path}";
                if (includeComments) psi.Arguments += " --include_source_info";
                if (includeImports) psi.Arguments += " --include_imports";
                psi.RedirectStandardError = psi.RedirectStandardOutput = true;
                psi.CreateNoWindow = true;
                psi.UseShellExecute = false;
                psi.WorkingDirectory = schemaPath;
                proc.Start();
                var stdout = proc.StandardOutput.ReadToEndAsync();
                var stderr = proc.StandardError.ReadToEndAsync();
                if (!proc.WaitForExit(5000))
                {
                    try { proc.Kill(); } catch { }
                }
                exitCode = proc.ExitCode;
                string err = "", @out = "";
                if (await stdout.WaitForAsync(1000)) @out = await stdout;
                if (await stdout.WaitForAsync(1000)) err = await stderr;

                if (!string.IsNullOrWhiteSpace(@out))
                {
                    _output.WriteLine("stdout: ");
                    _output.WriteLine(@out);
                }
                if (!string.IsNullOrWhiteSpace(err))
                {
                    _output.WriteLine("stderr: ");
                    _output.WriteLine(err);
                }
            }
            FileDescriptorSet set;
            string protocJson = null, jsonPath;
            if (exitCode == 0)
            {
                using var file = File.OpenRead(protocBinPath);
                set = CustomProtogenSerializer.Instance.Deserialize<FileDescriptorSet>(file);
                protocJson = JsonConvert.SerializeObject(set, Formatting.Indented, jsonSettings);
                jsonPath = Path.Combine(schemaPath, Path.ChangeExtension(path, "protoc.json"));
                File.WriteAllText(jsonPath, protocJson);
            }

            set = new FileDescriptorSet();

            set.AddImportPath(schemaPath);
            bool isProto3 = set.Add(path, includeInOutput: true) && set.Files[0].Syntax == "proto3";
            if (isProto3)
            {
                using var proc = new Process();
                var psi = proc.StartInfo;
                psi.FileName = protocExe;
                psi.Arguments = $"--experimental_allow_proto3_optional --csharp_out={Path.GetDirectoryName(protocBinPath)} {path}";
                psi.RedirectStandardError = psi.RedirectStandardOutput = true;
                psi.CreateNoWindow = true;
                psi.UseShellExecute = false;
                psi.WorkingDirectory = schemaPath;
                proc.Start();
                var stdout = proc.StandardOutput.ReadToEndAsync();
                var stderr = proc.StandardError.ReadToEndAsync();
                if (!proc.WaitForExit(5000))
                {
                    try { proc.Kill(); } catch { }
                }
                exitCode = proc.ExitCode;
                string err = "", @out = "";
                if (await stdout.WaitForAsync(1000)) @out = await stdout;
                if (await stderr.WaitForAsync(1000)) err = await stderr;

                if (!string.IsNullOrWhiteSpace(@out))
                {
                    _output.WriteLine("stdout (C#): ");
                    _output.WriteLine(@out);
                }
                if (!string.IsNullOrWhiteSpace(err))
                {
                    _output.WriteLine("stderr (C#): ");
                    _output.WriteLine(err);
                }
                _output.WriteLine("exit code(C#): " + exitCode);
            }

            set.Process();
            set.ApplyFileDependencyOrder();

            var parserBinPath = Path.Combine(schemaPath, Path.ChangeExtension(path, "parser.bin"));
            using (var file = File.Create(parserBinPath))
            {
                set.Serialize(CustomProtogenSerializer.Instance, file, includeImports);
            }

            var parserJson = set.Serialize((s, _) => JsonConvert.SerializeObject(s, Formatting.Indented, jsonSettings), includeImports);

            var errors = set.GetErrors();
            Exception genError = null;

            try
            {
                var options = new Dictionary<string, string>
                {
                    { "services", "true" },
                };
                foreach (var file in CSharpCodeGenerator.Default.Generate(set, options: options))
                {
                    var newExtension = "parser" + Path.GetExtension(file.Name);
                    var newFileName = Path.ChangeExtension(file.Name, newExtension);
                    File.WriteAllText(Path.Combine(schemaPath, newFileName), file.Text);
                }
            }
            catch (Exception ex)
            {
                genError = ex;
                _output.WriteLine(ex.Message);
                _output.WriteLine(ex.StackTrace);
            }

            jsonPath = Path.Combine(schemaPath, Path.ChangeExtension(path, "parser.json"));
            File.WriteAllText(jsonPath, parserJson);

            if (errors.Length > 0)
            {
                _output.WriteLine("Parser errors:");
                foreach (var err in errors) _output.WriteLine(err.ToString());
            }

            _output.WriteLine("Protoc exited with code " + exitCode);

            var errorCount = errors.Count(x => x.IsError);
            if (exitCode == 0)
            {
                Assert.Equal(0, errorCount);
            }
            else
            {
                Assert.NotEqual(0, errorCount);
            }

            var parserBytes = File.ReadAllBytes(parserBinPath);
            using (var ms = new MemoryStream(parserBytes))
            {
                var selfLoad = CustomProtogenSerializer.Instance.Deserialize<FileDescriptorSet>(ms);
                var selfLoadJson = JsonConvert.SerializeObject(selfLoad, Formatting.Indented, jsonSettings);
                // should still be the same! 
                Assert.Equal(parserJson, selfLoadJson);
            }
            var parserHex = GetPrettyHex(parserBytes);
            File.WriteAllText(Path.ChangeExtension(parserBinPath, "parser.hex"), parserHex);

            if (exitCode == 0)
            {
                var protocHex = GetPrettyHex(File.ReadAllBytes(protocBinPath));
                File.WriteAllText(Path.ChangeExtension(protocBinPath, "protoc.hex"), protocHex);

                switch(path)
                {
                    case "google/protobuf/unittest_custom_options.proto":
                    case "advancedOptions.proto":
                        // these are special cases; the two encoders choose slightly different
                        // layouts for the same data; both are valid; I'm happy that this is OK
                        // - this was why the "decode" tool (on the website) was written!
                        break;
                    case "google/protobuf/unittest.proto":
                        // ^^^ different layout of an integer; "2e+8" vs "200000000" - I'm fine with it
                        //
                        // the following end up importing unittest.proto, so have the same symptom
                    case "google/protobuf/map_unittest.proto" when (includeImports):
                    case "google/protobuf/unittest_optimize_for.proto" when (includeImports):
                    case "google/protobuf/unittest_embed_optimize_for.proto" when (includeImports):
                    case "google/protobuf/unittest_lite_imports_nonlite.proto" when (includeImports):
                    case "google/protobuf/unittest_no_field_presence.proto" when (includeImports):
                        break;
                    default:
                        // compare results
                        Assert.Equal(protocJson, parserJson);
                        Assert.Equal(protocHex, parserHex);
                        break;
                }
            }
            Assert.Null(genError);
        }

        private static bool IncludeComments(string _) => false;
        //{
        //    switch(path)
        //    {
        //        //case "everything.proto":
        //        //    return true;
        //        default:
        //            return false;
        //    }
        //}

        public SchemaTests(ITestOutputHelper output) => _output = output;

        public static string GetPrettyHex(byte[] bytes)
        {
            var sb = new StringBuilder();
            int left = bytes.Length, offset = 0;
            while(left > 0)
            {
                int take = Math.Min(left, 16);
                sb.AppendLine(BitConverter.ToString(bytes, offset, take));
                left -= take;
                offset += take;
            }
            return sb.ToString();
        }
    }

    static class TaskExtensions
    {
#if NETFRAMEWORK
        public static Task<bool> WaitForAsync(this Task task, int timeout)
            => task.Wait(timeout) ? SharedTrue : SharedFalse;

        private static readonly Task<bool> SharedTrue = Task.FromResult(true), SharedFalse = Task.FromResult(false);
#else
        public async static Task<bool> WaitForAsync(this Task task, int timeout)
        {
            try
            {
                await task.WaitAsync(TimeSpan.FromMilliseconds(timeout));
                return true;
            }
            catch (TimeoutException)
            {
                return false;
            }
        }
#endif
    }
}
