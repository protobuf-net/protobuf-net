using Google.Protobuf.Reflection;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ProtoBuf.Internal;

namespace ProtoBuf.Reflection
{
    /// <summary>
    /// A code generator that writes C#
    /// </summary>
    public class CSharpCodeGenerator : CommonCodeGenerator
    {
        /// <summary>
        /// Reusable code-generator instance
        /// </summary>
        public static CSharpCodeGenerator Default { get; } = new CSharpCodeGenerator();
        /// <summary>
        /// Create a new CSharpCodeGenerator instance
        /// </summary>
        protected CSharpCodeGenerator() { }
        /// <summary>
        /// Returns the language name
        /// </summary>
        public override string Name => "C#";
        /// <summary>
        /// Returns the default file extension
        /// </summary>
        protected override string DefaultFileExtension => "cs";
        /// <summary>
        /// Escapes language keywords
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0066:Convert switch statement to expression", Justification = "Readability")]
        protected override string Escape(string identifier)
        {
            switch (identifier)
            {
                case "abstract":
                case "event":
                case "new":
                case "struct":
                case "as":
                case "explicit":
                case "null":
                case "switch":
                case "base":
                case "extern":
                case "object":
                case "this":
                case "bool":
                case "false":
                case "operator":
                case "throw":
                case "break":
                case "finally":
                case "out":
                case "true":
                case "byte":
                case "fixed":
                case "override":
                case "try":
                case "case":
                case "float":
                case "params":
                case "typeof":
                case "catch":
                case "for":
                case "private":
                case "uint":
                case "char":
                case "foreach":
                case "protected":
                case "ulong":
                case "checked":
                case "goto":
                case "public":
                case "unchecked":
                case "class":
                case "if":
                case "readonly":
                case "unsafe":
                case "const":
                case "implicit":
                case "ref":
                case "ushort":
                case "continue":
                case "in":
                case "return":
                case "using":
                case "decimal":
                case "int":
                case "sbyte":
                case "virtual":
                case "default":
                case "interface":
                case "sealed":
                case "volatile":
                case "delegate":
                case "internal":
                case "short":
                case "void":
                case "do":
                case "is":
                case "sizeof":
                case "while":
                case "double":
                case "lock":
                case "stackalloc":
                case "else":
                case "long":
                case "static":
                case "enum":
                case "namespace":
                case "string":
                    return "@" + identifier;
                default:
                    return identifier;
            }
        }

        /// <summary>
        /// Get the language version for this language from a schema
        /// </summary>
        protected override string GetLanguageVersion(FileDescriptorProto obj)
            => obj?.Options?.GetOptions()?.CSharpLanguageVersion;

        private const string AdditionalSuppressionCodes = ", CS8981, IDE0079, IDE1006, RCS1036, RCS1057, RCS1085, RCS1192";

        /// <summary>
        /// Start a file
        /// </summary>
        protected override void WriteFileHeader(GeneratorContext ctx, FileDescriptorProto file, ref object state)
        {
            var prefix = ctx.Supports(CSharp6) ? "CS" : "";
            var tw = ctx.WriteLine("// <auto-generated>")
               .WriteLine("//   This file was generated by a tool; you should avoid making direct changes.")
               .WriteLine("//   Consider using 'partial classes' to extend these types")
               .WriteLine($"//   Input: {Path.GetFileName(ctx.File.Name)}")
               .WriteLine("// </auto-generated>")
               .WriteLine()
               .WriteLine("#region Designer generated code")
               .Write($"#pragma warning disable {prefix}0612, {prefix}0618, {prefix}1591, {prefix}3021");
            if (ctx.Supports(CSharp6))
            {
                tw.Write(AdditionalSuppressionCodes);
            }
            tw.WriteLine();
        }

        /// <inheritdoc/>
        protected override void WriteNamespaceHeader(GeneratorContext ctx, string @namespace)
        {
            ctx.WriteLine($"namespace {@namespace}");
            ctx.WriteLine("{").Indent().WriteLine();
        }

        /// <inheritdoc/>
        protected override void WriteNamespaceFooter(GeneratorContext ctx, string @namespace)
        {
            ctx.Outdent().WriteLine("}").WriteLine();
        }

        /// <summary>
        /// End a file
        /// </summary>
        protected override void WriteFileFooter(GeneratorContext ctx, FileDescriptorProto file, ref object state)
        {
            var prefix = ctx.Supports(CSharp6) ? "CS" : "";
            var tw = ctx.Write($"#pragma warning restore {prefix}0612, {prefix}0618, {prefix}1591, {prefix}3021");
            if (ctx.Supports(CSharp6))
            {
                tw.Write(AdditionalSuppressionCodes);
            }
            tw.WriteLine();
            tw.WriteLine("#endregion");
        }
        /// <summary>
        /// Start an enum
        /// </summary>
        protected override void WriteEnumHeader(GeneratorContext ctx, EnumDescriptorProto @enum, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(@enum);
            var tw = ctx.Write("[global::ProtoBuf.ProtoContract(");
            if (name != @enum.Name) tw.Write($@"Name = @""{@enum.Name}""");
            tw.WriteLine(")]");
            WriteOptions(ctx, @enum.Options);
            ctx.WriteLine($"{GetAccess(GetAccess(@enum))} enum {Escape(name)}").WriteLine("{").Indent();
        }
        /// <summary>
        /// End an enum
        /// </summary>

        protected override void WriteEnumFooter(GeneratorContext ctx, EnumDescriptorProto @enum, ref object state)
        {
            ctx.Outdent().WriteLine("}").WriteLine();
        }
        /// <summary>
        /// Write an enum value
        /// </summary>
        protected override void WriteEnumValue(GeneratorContext ctx, EnumValueDescriptorProto @enum, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(@enum);
            if (name != @enum.Name)
            {
                var tw = ctx.Write("[global::ProtoBuf.ProtoEnum(");
                tw.Write($@"Name = @""{@enum.Name}""");
                tw.WriteLine(")]");
            }

            WriteOptions(ctx, @enum.Options);
            ctx.WriteLine($"{Escape(name)} = {@enum.Number},");
        }

        /// <summary>
        /// End a message
        /// </summary>
        protected override void WriteMessageFooter(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            //if (UsePooledMemory(ctx, message))
            //{
            //    ctx.Write("public virtual void Dispose()").WriteLine();
            //    ctx.WriteLine("{").Indent();
            //    bool first = true;
            //    foreach (var field in message.Fields)
            //    {
            //        if (field.type == FieldDescriptorProto.Type.TypeBytes)
            //        {
            //            var member = Escape(ctx.NameNormalizer.GetName(field));
            //            ctx.WriteLine($"{(first ? "var " : "")}__oldMemory = {member};");
            //            ctx.WriteLine($"{member} = default{(ctx.Supports(CSharp7_1) ? "" : "(global::ProtoBuf.PooledMemory<byte>)")};");
            //            ctx.WriteLine("__oldMemory.Dispose();");
            //            first = false;
            //        }
            //    }
            //    ctx.WriteLine("OnDispose(); // invoke user-defined additional dispose features, if any");
            //    ctx.Outdent().WriteLine("}").WriteLine("partial void OnDispose(); // implement in a partial class to add additional dispose features").WriteLine();
            //}
            ctx.Outdent().WriteLine("}").WriteLine();
        }
        /// <summary>
        /// Start a message
        /// </summary>
        protected override void WriteMessageHeader(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(message);
            var tw = ctx.Write("[global::ProtoBuf.ProtoContract(");
            if (name != message.Name) tw.Write($@"Name = @""{message.Name}""");
            tw.WriteLine(")]");
            WriteOptions(ctx, message.Options);
            tw = ctx.Write($"{GetAccess(GetAccess(message))} partial class {Escape(name)}");
            tw.Write(" : global::ProtoBuf.IExtensible");
            //if (UsePooledMemory(ctx, message))
            //{
            //    tw.Write(", global::System.IDisposable");
            //}
            tw.WriteLine();
            ctx.WriteLine("{").Indent();
            if (message.Options?.MessageSetWireFormat == true)
            {
                ctx.WriteLine("#error message_set_wire_format is not currently implemented").WriteLine();
            }

            ctx.WriteLine($"private global::ProtoBuf.IExtension {FieldPrefix}extensionData;")
                .WriteLine($"global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)");

            if (ctx.Supports(CSharp6))
            {
                ctx.Indent().WriteLine($"=> global::ProtoBuf.Extensible.GetExtensionObject(ref {FieldPrefix}extensionData, createIfMissing);").Outdent().WriteLine();
            }
            else
            {
                ctx.WriteLine("{").Indent().WriteLine($"return global::ProtoBuf.Extensible.GetExtensionObject(ref {FieldPrefix}extensionData, createIfMissing);").Outdent().WriteLine("}");
            }
        }

        private static void WriteOptions<T>(GeneratorContext ctx, T obj) where T : class, ISchemaOptions
        {
            if (obj == null) return;
            if (obj.Deprecated)
            {
                ctx.WriteLine($"[global::System.Obsolete]");
            }
        }

        private const string FieldPrefix = "__pbn__";

        /// <summary>
        /// Get the language specific keyword representing an access level
        /// </summary>
        public override string GetAccess(Access access)
        {
            return access switch
            {
                Access.Internal => "internal",
                Access.Public => "public",
                Access.Private => "private",
                _ => base.GetAccess(access),
            };
        }

        /// <summary>
        /// Emit code beginning a constructor, if one is required
        /// </summary>
        /// <returns>true if a constructor is required</returns>
        protected override bool WriteContructorHeader(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            if (ctx.Supports(CSharp6)) return false;

            var name = ctx.NameNormalizer.GetName(message);
            ctx.WriteLine($"public {Escape(name)}()") // note: the .ctor is still public even if the type is internal; it is protected by the scope
                .WriteLine("{").Indent();
            return true;
        }

        /// <summary>
        /// Emit code terminating a constructor, if one is required
        /// </summary>
        protected override void WriteConstructorFooter(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            if (ctx.Supports(CSharp3))
            {
                ctx.WriteLine("OnConstructor();");
            }
            ctx.Outdent().WriteLine("}").WriteLine();

            if (ctx.Supports(CSharp3))
            {
                ctx.WriteLine("partial void OnConstructor();")
                .WriteLine();
            }
        }

        /// <summary>
        /// Emit code initializing field values inside a constructor, if one is required
        /// </summary>
        protected override void WriteInitField(GeneratorContext ctx, FieldDescriptorProto field, ref object state, OneOfStub[] oneOfs)
        {
            var name = ctx.NameNormalizer.GetName(field);
            bool isOptional = field.label == FieldDescriptorProto.Label.LabelOptional;
            bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
            var typeName = GetTypeName(ctx, field, out var dataFormat, out _, out _, out var isMap);
            bool trackPresence = TrackFieldPresence(ctx, field, oneOfs, out _);

            string defaultValue = GetDefaultValue(ctx, field, typeName, out var suffix);

            if (isRepeated)
            {
                var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                if (mapMsgType != null)
                {
                    var keyTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 1),
                        out var keyDataFormat, out _, out _, out _);
                    var valueTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 2),
                        out var valueDataFormat, out _, out _, out _);
                    ctx.WriteLine($"{Escape(name)} = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>();");
                }
                else if (ctx.RepeatedAsList || !UseArray(field))
                {
                    ctx.WriteLine($"{Escape(name)} = new global::System.Collections.Generic.List<{typeName}>();");
                }
            }
            else if (!trackPresence)
            {
                if (!string.IsNullOrWhiteSpace(defaultValue))
                {
                    ctx.WriteLine($"{Escape(name)} = {defaultValue}{suffix};");
                }
            }
        }

        private string GetDefaultValue(GeneratorContext ctx, FieldDescriptorProto obj, string typeName, out string suffix)
        {
            string defaultValue = null;
            bool isOptional = obj.label == FieldDescriptorProto.Label.LabelOptional;
            suffix = "";
            if (isOptional || ctx.EmitRequiredDefaults || obj.type == FieldDescriptorProto.Type.TypeEnum)
            {
                defaultValue = obj.DefaultValue;

                switch (obj.type)
                {
                    case FieldDescriptorProto.Type.TypeString:
                        defaultValue = string.IsNullOrEmpty(defaultValue) ? "\"\""
                        : ("@\"" + (defaultValue ?? "").Replace("\"", "\"\"") + "\"");
                        break;
                    case FieldDescriptorProto.Type.TypeDouble:
                        switch (defaultValue)
                        {
                            case "inf": defaultValue = "double.PositiveInfinity"; break;
                            case "-inf": defaultValue = "double.NegativeInfinity"; break;
                            case "nan": defaultValue = "double.NaN"; break;
                            default: suffix = "d"; break;
                        }
                        break;
                    case FieldDescriptorProto.Type.TypeFloat:
                        switch (defaultValue)
                        {
                            case "inf": defaultValue = "float.PositiveInfinity"; break;
                            case "-inf": defaultValue = "float.NegativeInfinity"; break;
                            case "nan": defaultValue = "float.NaN"; break;
                            default: suffix = "f"; break;
                        }
                        break;
                    case FieldDescriptorProto.Type.TypeSfixed64:
                    case FieldDescriptorProto.Type.TypeSint64:
                    case FieldDescriptorProto.Type.TypeInt64:
                        suffix = "l";
                        break;
                    case FieldDescriptorProto.Type.TypeFixed64:
                    case FieldDescriptorProto.Type.TypeUint64:
                        suffix = "ul";
                        break;
                    case FieldDescriptorProto.Type.TypeFixed32:
                    case FieldDescriptorProto.Type.TypeUint32:
                        suffix = "u";
                        break;
                    case FieldDescriptorProto.Type.TypeEnum:
                        var enumType = ctx.TryFind<EnumDescriptorProto>(obj.TypeName);
                        if (enumType != null)
                        {
                            EnumValueDescriptorProto found = null;
                            if (!string.IsNullOrEmpty(defaultValue))
                            {
                                found = enumType.Values.Find(x => x.Name == defaultValue);
                            }
                            else if (ctx.Syntax == FileDescriptorProto.SyntaxProto2)
                            {
                                // find the first one; if that is a zero, we don't need it after all
                                found = enumType.Values.FirstOrDefault();
                                if (found != null && found.Number == 0)
                                {
                                    if (!isOptional) found = null; // we don't need it after all
                                }
                            }
                            // for proto3 the default is 0, so no need to do anything - GetValueOrDefault() will do it all

                            if (found != null)
                            {
                                defaultValue = ctx.NameNormalizer.GetName(found);
                            }
                            if (!string.IsNullOrWhiteSpace(defaultValue))
                            {
                                defaultValue = typeName + "." + defaultValue;
                            }
                        }
                        break;
                }
            }

            return defaultValue;
        }
        /// <summary>
        /// Write a field
        /// </summary>
        protected override void WriteField(GeneratorContext ctx, FieldDescriptorProto field, ref object state, OneOfStub[] oneOfs)
        {
            var name = ctx.NameNormalizer.GetName(field);
            var tw = ctx.Write($"[global::ProtoBuf.ProtoMember({field.Number}");
            if (name != field.Name)
            {
                tw.Write($@", Name = @""{field.Name}""");
            }
            var options = field.Options?.GetOptions();
            if (options?.AsReference == true)
            {
                tw.Write(", AsReference = true");
            }
            if (options?.DynamicType == true)
            {
                tw.Write(", DynamicType = true");
            }

            bool isOptional = field.label == FieldDescriptorProto.Label.LabelOptional;
            bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;

            bool trackPresence = TrackFieldPresence(ctx, field, oneOfs, out var oneOf);

            bool suppressDefaultAttribute = !isOptional;
            var typeName = GetTypeName(ctx, field, out var dataFormat, out var nullabilityType, out var compatibilityLevel, out var isMap);
            string defaultValue = GetDefaultValue(ctx, field, typeName, out var suffix);

            WriteDataFormatAttribute();
            WriteNullabilityTypeAttribute();
            WriteCompatibilityLevelAttribute();

            void WriteDataFormatAttribute()
            {
                if (!string.IsNullOrWhiteSpace(dataFormat))
                {
                    tw.Write($", DataFormat = global::ProtoBuf.DataFormat.{dataFormat}");
                }
                if (field.IsPackedField(ctx.Syntax))
                {
                    tw.Write($", IsPacked = true");
                }
                if (field.label == FieldDescriptorProto.Label.LabelRequired)
                {
                    tw.Write($", IsRequired = true");
                }
                tw.WriteLine(")]");
            }

            void WriteNullabilityTypeAttribute()
            {
                if (!nullabilityType.HasValue) return;
                switch (nullabilityType)
                {
                    case NullabilityType.NullWrappedValue: ctx.WriteLine("[global::ProtoBuf.NullWrappedValue]"); break;
                    case NullabilityType.NullWrappedValueAsGroup: ctx.WriteLine("[global::ProtoBuf.NullWrappedValue(AsGroup = true)]"); break;
                }
            }

            void WriteCompatibilityLevelAttribute()
            {
                if (!compatibilityLevel.HasValue) return;
                ctx.WriteLine($"[global::ProtoBuf.CompatibilityLevel(global::ProtoBuf.CompatibilityLevel.{compatibilityLevel.Value})]");
            }
            
            if (!isRepeated && !string.IsNullOrWhiteSpace(defaultValue) && !suppressDefaultAttribute)
            {
                switch (field.type)
                {
                    case FieldDescriptorProto.Type.TypeFixed64:
                    case FieldDescriptorProto.Type.TypeUint64:
                        ctx.WriteLine($"[global::System.ComponentModel.DefaultValue(typeof(ulong), \"{defaultValue}\")]");
                        break;
                    default:
                        ctx.WriteLine($"[global::System.ComponentModel.DefaultValue({defaultValue}{suffix})]");
                        break;
                }
            }
            WriteOptions(ctx, field.Options);
            if (isRepeated)
            {
                var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                bool allowSet = ctx.EmitListSetters;
                if (mapMsgType != null)
                {
                    var keyTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 1),
                        out var keyDataFormat, out _, out _, out var _);
                    var valueTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 2),
                        out var valueDataFormat, out _, out _, out var _);

                    bool first = true;
                    tw = ctx.Write($"[global::ProtoBuf.ProtoMap");
                    if (!string.IsNullOrWhiteSpace(keyDataFormat))
                    {
                        tw.Write($"{(first ? "(" : ", ")}KeyFormat = global::ProtoBuf.DataFormat.{keyDataFormat}");
                        first = false;
                    }
                    if (!string.IsNullOrWhiteSpace(valueDataFormat))
                    {
                        tw.Write($"{(first ? "(" : ", ")}ValueFormat = global::ProtoBuf.DataFormat.{valueDataFormat}");
                        first = false;
                    }
                    tw.WriteLine(first ? "]" : ")]");
                    if (ctx.Supports(CSharp6))
                    {
                        ctx.WriteLine($"{GetAccess(GetAccess(field))} global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}> {Escape(name)} {{ get; {(allowSet ? "set; " : "")}}} = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>();");
                    }
                    else
                    {
                        ctx.WriteLine($"{GetAccess(GetAccess(field))} global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}> {Escape(name)} {{ get; {(allowSet ? "" : "private ")}set; }}");
                    }
                }
                else if (!ctx.RepeatedAsList && UseArray(field))
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} {typeName}[] {Escape(name)} {{ get; set; }}");
                }
                else if (ctx.Supports(CSharp6))
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} global::System.Collections.Generic.List<{typeName}> {Escape(name)} {{ get; {(allowSet ? "set; " : "")}}} = new global::System.Collections.Generic.List<{typeName}>();");
                }
                else
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} global::System.Collections.Generic.List<{typeName}> {Escape(name)} {{ get; {(allowSet ? "" : "private ")}set; }}");
                }
            }
            else if (oneOf is not null)
            {
                var defValue = string.IsNullOrWhiteSpace(defaultValue) ? (ctx.Supports(CSharp7_1) ? "default" : $"default({typeName})") : (defaultValue + suffix);
                var fieldName = GetOneOfFieldName(oneOf.OneOf);
                var storage = oneOf.GetStorage(field.type, field.TypeName);
                ctx.WriteLine($"{GetAccess(GetAccess(field))} {typeName} {Escape(name)}").WriteLine("{").Indent();

                switch (field.type)
                {
                    case FieldDescriptorProto.Type.TypeMessage:
                    case FieldDescriptorProto.Type.TypeGroup:
                    case FieldDescriptorProto.Type.TypeEnum:
                    case FieldDescriptorProto.Type.TypeBytes:
                    case FieldDescriptorProto.Type.TypeString:
                        ctx.WriteLine($"{PropGetPrefix()}{fieldName}.Is({field.Number}) ? (({typeName}){fieldName}.{storage}) : {defValue};{PropSuffix()}");
                        break;
                    default:
                        ctx.WriteLine($"{PropGetPrefix()}{fieldName}.Is({field.Number}) ? {fieldName}.{storage} : {defValue};{PropSuffix()}");
                        break;
                }
                var unionType = oneOf.GetUnionType();
                var cast = field.type == FieldDescriptorProto.Type.TypeEnum ? "(int)" : "";
                ctx.WriteLine($"{PropSetPrefix()}{fieldName} = new global::ProtoBuf.{unionType}({field.Number}, {cast}value);{PropSuffix()}")
                    .Outdent().WriteLine("}");

                if (ctx.Supports(CSharp6))
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} bool ShouldSerialize{name}() => {fieldName}.Is({field.Number});")
                    .WriteLine($"{GetAccess(GetAccess(field))} void Reset{name}() => global::ProtoBuf.{unionType}.Reset(ref {fieldName}, {field.Number});");
                }
                else
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} bool ShouldSerialize{name}()").WriteLine("{").Indent()
                        .WriteLine($"return {fieldName}.Is({field.Number});").Outdent().WriteLine("}")
                        .WriteLine($"{GetAccess(GetAccess(field))} void Reset{name}()").WriteLine("{").Indent()
                        .WriteLine($"global::ProtoBuf.{unionType}.Reset(ref {fieldName}, {field.Number});").Outdent().WriteLine("}");
                }

                if (oneOf.IsFirst())
                {
                    ctx.WriteLine().WriteLine($"private global::ProtoBuf.{unionType} {fieldName};");
                }
            }
            else if (trackPresence)
            {
                bool isNullable = IsNullableType(ctx, field, defaultValue, isOptional);
                string fieldName = FieldPrefix + name, fieldType;
                bool isRef = false;
                switch (field.type)
                {
                    case FieldDescriptorProto.Type.TypeString:
                    case FieldDescriptorProto.Type.TypeBytes:
                        fieldType = typeName;
                        isRef = true;
                        break;
                    default:
                        fieldType = typeName + "?";
                        isRef = isNullable;
                        break;
                }
                ctx.WriteLine($"{GetAccess(GetAccess(field))} {typeName}{(isNullable ? "?": "")} {Escape(name)}").WriteLine("{").Indent();
                tw = ctx.Write(PropGetPrefix());
                tw.Write(fieldName);
                if (!string.IsNullOrWhiteSpace(defaultValue))
                {
                    tw.Write(" ?? ");
                    tw.Write(defaultValue);
                    tw.Write(suffix);
                }
                else if (!isRef)
                {
                    tw.Write(".GetValueOrDefault()");
                }
                tw.Write(";");
                tw.WriteLine(PropSuffix());

                ctx.WriteLine($"{PropSetPrefix()}{fieldName} = value;{PropSuffix()}")
                    .Outdent().WriteLine("}");
                if (ctx.Supports(CSharp6))
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} bool ShouldSerialize{name}() => {fieldName} != null;")
                    .WriteLine($"{GetAccess(GetAccess(field))} void Reset{name}() => {fieldName} = null;");
                }
                else
                {
                    ctx.WriteLine($"{GetAccess(GetAccess(field))} bool ShouldSerialize{name}()").WriteLine("{").Indent()
                        .WriteLine($"return {fieldName} != null;").Outdent().WriteLine("}")
                        .WriteLine($"{GetAccess(GetAccess(field))} void Reset{name}()").WriteLine("{").Indent()
                        .WriteLine($"{fieldName} = null;").Outdent().WriteLine("}");
                }
                ctx.WriteLine($"private {fieldType} {fieldName};");
            }
            else
            {
                tw = ctx.Write($"{GetAccess(GetAccess(field))} {typeName}{(IsNullableType(ctx, field, defaultValue, isOptional) ? "?" : "")} {Escape(name)} {{ get; set; }}");
                if (!string.IsNullOrWhiteSpace(defaultValue) && ctx.Supports(CSharp6)) tw.Write($" = {defaultValue}{suffix};");
                tw.WriteLine();
            }
            ctx.WriteLine();

            string PropGetPrefix() => ctx.Supports(CSharp7) ? "get => " : "get { return ";
            string PropSetPrefix() => ctx.Supports(CSharp7) ? "set => " : "set { ";
            string PropSuffix() => ctx.Supports(CSharp7) ? "" : " }";
        }

        private static string GetOneOfFieldName(OneofDescriptorProto obj) => FieldPrefix + obj.Name;

        private static readonly Version // note: only mentioning features we use
            CSharp3 = new Version(3, 0), // partial methods
            CSharp4 = new Version(4, 0), // optional parameters
            CSharp6 = new Version(6, 0), // pragma prefixes, method expressions, property initializers
            CSharp7 = new Version(7, 0), // property expressions
            CSharp7_1 = new Version(7, 1); // default literals

        /// <summary>
        /// Starts an extensions block
        /// </summary>
        protected override void WriteExtensionsHeader(GeneratorContext ctx, FileDescriptorProto file, ref object state)
        {
            var name = file?.Options?.GetOptions()?.ExtensionTypeName;
            if (string.IsNullOrWhiteSpace(name)) name = "Extensions";
            ctx.WriteLine($"{GetAccess(GetAccess(file))} static partial class {Escape(name)}").WriteLine("{").Indent();
        }
        /// <summary>
        /// Ends an extensions block
        /// </summary>
        protected override void WriteExtensionsFooter(GeneratorContext ctx, FileDescriptorProto file, ref object state)
        {
            ctx.Outdent().WriteLine("}");
        }
        /// <summary>
        /// Starts an extensions block
        /// </summary>
        protected override void WriteExtensionsHeader(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            var name = message?.Options?.GetOptions()?.ExtensionTypeName;
            if (string.IsNullOrWhiteSpace(name)) name = "Extensions";
            ctx.WriteLine($"{GetAccess(GetAccess(message))} static partial class {Escape(name)}").WriteLine("{").Indent();
        }
        /// <summary>
        /// Ends an extensions block
        /// </summary>
        protected override void WriteExtensionsFooter(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            ctx.Outdent().WriteLine("}");
        }
        /// <summary>
        /// Write an extension
        /// </summary>
        protected override void WriteExtension(GeneratorContext ctx, FieldDescriptorProto field)
        {
            var type = GetTypeName(ctx, field, out string dataFormat, out _, out _, out bool isMap, false);
            var nonNullableType = GetTypeName(ctx, field, out _, out _, out _, out _, true);
            var msg = ctx.TryFind<DescriptorProto>(field.Extendee);
            var extendee = MakeRelativeName(field, msg, ctx.NameNormalizer);

            var @this = field.Parent is FileDescriptorProto ? "this " : "";
            string name = ctx.NameNormalizer.GetName(field);
            TextWriter tw;

            if (isMap)
            {
                ctx.WriteLine("#error map extensions not yet implemented; please file an issue");
            }
            else
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;

                var getMethodName = isRepeated ? nameof(Extensible.GetValues) : nameof(Extensible.GetValue);
                if(isRepeated) ctx.WriteLine($"{GetAccess(GetAccess(field))} static global::System.Collections.Generic.IEnumerable<{nonNullableType}> Get{name}({@this}{extendee} obj)");
                else ctx.WriteLine($"{GetAccess(GetAccess(field))} static {type} Get{name}({@this}{extendee} obj)");
                if (ctx.Supports(CSharp6))
                {
                    tw = ctx.Indent().Write($"=> ");
                }
                else
                {
                    ctx.WriteLine("{").Indent();
                    tw = ctx.Write("return ");
                }
                var defaultValue = isRepeated ? "null" : ctx.Supports(CSharp7_1) ? "default" : $"default({type})";
                tw.Write($"obj == null ? {defaultValue} : global::ProtoBuf.Extensible.{getMethodName}<{(isRepeated ? nonNullableType : type)}>(obj, {field.Number}");
                if (!string.IsNullOrEmpty(dataFormat))
                {
                    tw.Write($", global::ProtoBuf.DataFormat.{dataFormat}");
                }
                tw.WriteLine(");");
                if (ctx.Supports(CSharp6)) ctx.Outdent().WriteLine();
                else ctx.Outdent().WriteLine("}").WriteLine();

                var setAccessorName = isRepeated ? "Add" : "Set";
                ctx.WriteLine($"{GetAccess(GetAccess(field))} static void {setAccessorName}{name}({@this}{extendee} obj, {nonNullableType} value)");
                if (ctx.Supports(CSharp6))
                {
                    tw = ctx.Indent().Write($"=> ");
                }
                else
                {
                    ctx.WriteLine("{").Indent();
                    tw = ctx.Write("");
                }
                tw.Write($"global::ProtoBuf.Extensible.AppendValue<{nonNullableType}>(obj, {field.Number}");
                if (!string.IsNullOrEmpty(dataFormat))
                {
                    tw.Write($", global::ProtoBuf.DataFormat.{dataFormat}");
                }
                tw.WriteLine(", value);");
                if (ctx.Supports(CSharp6)) ctx.Outdent().WriteLine();
                else ctx.Outdent().WriteLine("}").WriteLine();
            }
        }

        /// <summary>
        /// Emit the start of an enum declaration for 'oneof' groups, including the 0/None element
        /// </summary>
        protected override void WriteOneOfEnumHeader(GeneratorContext ctx, OneofDescriptorProto oneof, ref object state)
        {
            ctx.WriteLine().WriteLine($"public enum {ctx.NameNormalizer.GetName(oneof)}{OneOfEnumSuffixEnum}").WriteLine("{").Indent().WriteLine("None = 0,");
        }
        /// <summary>
        /// Emit the end of an enum declaration for 'oneof' groups
        /// </summary>
        protected override void WriteOneOfEnumFooter(GeneratorContext ctx, OneofDescriptorProto oneof, ref object state)
        {
            ctx.Outdent().WriteLine("}").WriteLine();
        }

        /// <summary>
        /// Emit a field-based entry for a 'oneof' groups's enum
        /// </summary>
        protected override void WriteOneOfEnumValue(GeneratorContext ctx, FieldDescriptorProto field, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(field);
            ctx.WriteLine($"{Escape(name)} = {field.Number},");
        }
        /// <summary>
        /// Emit  the discriminator accessor for 'oneof' groups
        /// </summary>
        protected override void WriteOneOfDiscriminator(GeneratorContext ctx, OneofDescriptorProto oneof, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(oneof);
            var fieldName = GetOneOfFieldName(oneof);
            if (ctx.Supports(CSharp6))
            {
                ctx.WriteLine($"public {name}{OneOfEnumSuffixEnum} {name}{OneOfEnumSuffixDiscriminator} => ({name}{OneOfEnumSuffixEnum}){fieldName}.Discriminator;");
            }
            else
            {
                ctx.WriteLine($"public {name}{OneOfEnumSuffixEnum} {name}{OneOfEnumSuffixDiscriminator}").WriteLine("{").Indent()
                    .WriteLine($"get {{ return ({name}{OneOfEnumSuffixEnum}){fieldName}.Discriminator; }}")
                    .Outdent().WriteLine("}");
            }
        }

        /// <summary>
        /// Indicate which types will commonly use arrays
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0066:Convert switch statement to expression", Justification = "Readability")]
        protected virtual bool UseArray(FieldDescriptorProto field)
        {
            switch (field.type)
            {
                case FieldDescriptorProto.Type.TypeBool:
                case FieldDescriptorProto.Type.TypeDouble:
                case FieldDescriptorProto.Type.TypeFixed32:
                case FieldDescriptorProto.Type.TypeFixed64:
                case FieldDescriptorProto.Type.TypeFloat:
                case FieldDescriptorProto.Type.TypeInt32:
                case FieldDescriptorProto.Type.TypeInt64:
                case FieldDescriptorProto.Type.TypeSfixed32:
                case FieldDescriptorProto.Type.TypeSfixed64:
                case FieldDescriptorProto.Type.TypeSint32:
                case FieldDescriptorProto.Type.TypeSint64:
                case FieldDescriptorProto.Type.TypeUint32:
                case FieldDescriptorProto.Type.TypeUint64:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Obtain a relative name from a type name
        /// </summary>
        protected string MakeRelativeName(GeneratorContext ctx, string typeName)
        {
            var target = ctx.TryFind<DescriptorProto>(typeName);
            if (target != null && target.Parent is IType type)
            {
                var name = FindNameFromCommonAncestor(type, target, ctx.NameNormalizer);
                if (!string.IsNullOrWhiteSpace(name))
                {
                    return name;
                }
            }

            return Escape(typeName);
        }

        private string GetTypeName(GeneratorContext ctx, string typeName)
        {
            string dataFormat = "";
            NullabilityType? nullabilityType = null;
            CompatibilityLevel? compatibilityLevel = null;
            bool isMap = false;
            return GetTypeName(ctx, null, typeName, ref dataFormat, ref nullabilityType, ref compatibilityLevel, ref isMap, false);
        }

        private string GetTypeName(
            GeneratorContext ctx, 
            FieldDescriptorProto field, 
            string typeName, 
            ref string dataFormat,
            ref NullabilityType? nullabilityType,
            ref CompatibilityLevel? compatibilityLevel,
            ref bool isMap,
            bool nonNullable = false)
        {
            if (ctx.EmitNullWrappers)
            {
                switch (typeName)
                {
                    case WellKnownTypeDouble:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "double?";
                    case WellKnownTypeFloat:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "float?";
                    case WellKnownTypeInt64:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "long?";
                    case WellKnownTypeUInt64:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "ulong?";
                    case WellKnownTypeInt32:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "int?";
                    case WellKnownTypeUInt32:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "uint?";
                    case WellKnownTypeBool:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "bool?";
                    case WellKnownTypeString:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "string";
                    case WellKnownTypeBytes:
                        nullabilityType = NullabilityType.NullWrappedValue;
                        return "byte[]";
                }
            }
            
            switch (typeName)
            {
                case WellKnownTypeTimestamp:
                    if (ctx.EmitCompatibilityLevelAttribute) compatibilityLevel = CompatibilityLevel.Level300;
                    else dataFormat = "WellKnown";
                    return nonNullable ? "global::System.DateTime" : "global::System.DateTime?";
                case WellKnownTypeDuration:
                    if (ctx.EmitCompatibilityLevelAttribute) compatibilityLevel = CompatibilityLevel.Level300;
                    else dataFormat = "WellKnown";
                    return nonNullable ? "global::System.TimeSpan" : "global::System.TimeSpan?";
                
                case WellKnownTypeEmpty:
                    return "global::ProtoBuf.Empty";

                case ".bcl.NetObjectProxy":
                    return "object";
                case ".bcl.DateTime":
                    return nonNullable ? "global::System.DateTime" : "global::System.DateTime?";
                case ".bcl.TimeSpan":
                    return nonNullable ? "global::System.TimeSpan" : "global::System.TimeSpan?";
                case ".bcl.Decimal":
                    return nonNullable ? "decimal" : "decimal?";
                case ".bcl.Guid":
                    return nonNullable ? "global::System.Guid" : "global::System.Guid?";
            }
            
            var msgType = ctx.TryFind<DescriptorProto>(typeName);
            if ( field!= null && field.type == FieldDescriptorProto.Type.TypeGroup)
            {
                dataFormat = nameof(DataFormat.Group);
            }
            isMap = msgType?.Options?.MapEntry ?? false;
            return field == null ? MakeRelativeName(ctx, typeName) : MakeRelativeName(field, msgType, ctx.NameNormalizer);
        }
        private string GetTypeName(
            GeneratorContext ctx,
            FieldDescriptorProto field,
            out string dataFormat,
            out NullabilityType? nullabilityType,
            out CompatibilityLevel? compatibilityLevel,
            out bool isMap,
            bool nonNullable = false)
        {
            dataFormat = "";
            nullabilityType = null;
            compatibilityLevel = null;
            isMap = false;
            switch (field.type)
            {
                case FieldDescriptorProto.Type.TypeDouble:
                    return "double";
                case FieldDescriptorProto.Type.TypeFloat:
                    return "float";
                case FieldDescriptorProto.Type.TypeBool:
                    return "bool";
                case FieldDescriptorProto.Type.TypeString:
                    return "string";
                case FieldDescriptorProto.Type.TypeSint32:
                    dataFormat = nameof(DataFormat.ZigZag);
                    return "int";
                case FieldDescriptorProto.Type.TypeInt32:
                    return "int";
                case FieldDescriptorProto.Type.TypeSfixed32:
                    dataFormat = nameof(DataFormat.FixedSize);
                    return "int";
                case FieldDescriptorProto.Type.TypeSint64:
                    dataFormat = nameof(DataFormat.ZigZag);
                    return "long";
                case FieldDescriptorProto.Type.TypeInt64:
                    return "long";
                case FieldDescriptorProto.Type.TypeSfixed64:
                    dataFormat = nameof(DataFormat.FixedSize);
                    return "long";
                case FieldDescriptorProto.Type.TypeFixed32:
                    dataFormat = nameof(DataFormat.FixedSize);
                    return "uint";
                case FieldDescriptorProto.Type.TypeUint32:
                    return "uint";
                case FieldDescriptorProto.Type.TypeFixed64:
                    dataFormat = nameof(DataFormat.FixedSize);
                    return "ulong";
                case FieldDescriptorProto.Type.TypeUint64:
                    return "ulong";
                case FieldDescriptorProto.Type.TypeBytes:
                    return UseMemory(ctx) ? "global::System.Memory<byte>" : "byte[]";
                case FieldDescriptorProto.Type.TypeEnum:
                    switch (field.TypeName)
                    {
                        case ".bcl.DateTime.DateTimeKind":
                            return "global::System.DateTimeKind";
                    }
                    var enumType = ctx.TryFind<EnumDescriptorProto>(field.TypeName);
                    return MakeRelativeName(field, enumType, ctx.NameNormalizer);
                case FieldDescriptorProto.Type.TypeGroup:
                case FieldDescriptorProto.Type.TypeMessage:
                    return GetTypeName(ctx, field, field.TypeName, ref dataFormat, ref nullabilityType, ref compatibilityLevel, ref isMap, nonNullable);
                default:
                    return field.TypeName;
            }
        }
        private bool IsNullableType(GeneratorContext ctx, FieldDescriptorProto field, string defaultValue, bool isOptional)
        {
            if (!(ctx.IsEnabled("nullablevaluetype") && string.IsNullOrWhiteSpace(defaultValue) && isOptional))
                return false;

            switch (field.type)
            {
                case FieldDescriptorProto.Type.TypeDouble:
                case FieldDescriptorProto.Type.TypeFloat:
                case FieldDescriptorProto.Type.TypeBool:
                case FieldDescriptorProto.Type.TypeSint32:
                case FieldDescriptorProto.Type.TypeInt32:
                case FieldDescriptorProto.Type.TypeSfixed32:
                case FieldDescriptorProto.Type.TypeSint64:
                case FieldDescriptorProto.Type.TypeInt64:
                case FieldDescriptorProto.Type.TypeSfixed64:
                case FieldDescriptorProto.Type.TypeFixed32:
                case FieldDescriptorProto.Type.TypeUint32:
                case FieldDescriptorProto.Type.TypeFixed64:
                case FieldDescriptorProto.Type.TypeUint64:
                    return true;
                default:
                    return false;
            }
        }

        private string MakeRelativeName(FieldDescriptorProto field, IType target, NameNormalizer normalizer)
        {
            if (target == null) return Escape(field.TypeName); // the only thing we know

            switch(target)
            {
                case DescriptorProto message:
                    var overrideNs = message.Options?.GetOptions()?.Namespace;
                    if (!string.IsNullOrWhiteSpace(overrideNs))
                        return "global::" + overrideNs + "." + Escape(normalizer.GetName(message));
                    break;
                case EnumDescriptorProto @enum:
                    overrideNs = @enum.Options?.GetOptions()?.Namespace;
                    if (!string.IsNullOrWhiteSpace(overrideNs))
                        return "global::" + overrideNs + "." + Escape(normalizer.GetName(@enum));
                    break;
            };

            var declaringType = field.Parent;

            if (declaringType is IType type)
            {
                var name = FindNameFromCommonAncestor(type, target, normalizer);
                if (!string.IsNullOrWhiteSpace(name)) return name;
            }
            return Escape(field.TypeName); // give up!
        }

        // k, what we do is; we have two types; each knows the parent, but nothing else, so:
        // for each, use a stack to build the ancestry tree - the "top" of the stack will be the
        // package, the bottom of the stack will be the type itself. They will often be stacks
        // of different heights.
        //
        // Find how many is in the smallest stack; now take that many items, in turn, until we
        // get something that is different (at which point, put that one back on the stack), or 
        // we run out of items in one of the stacks.
        //
        // There are now two options:
        // - we ran out of things in the "target" stack - in which case, they are common enough to not
        //   need any resolution - just give back the fixed name
        // - we have things left in the "target" stack - in which case we have found a common ancestor,
        //   or the target is a descendent; either way, just concat what is left (including the package
        //   if the package itself was different)

        private string FindNameFromCommonAncestor(IType declaring, IType target, NameNormalizer normalizer)
        {
            // trivial case; asking for self, or asking for immediate child
            if (ReferenceEquals(declaring, target) || ReferenceEquals(declaring, target.Parent))
            {
                if (target is DescriptorProto message) return Escape(normalizer.GetName(message));
                if (target is EnumDescriptorProto @enum) return Escape(normalizer.GetName(@enum));
                return null;
            }

            var origTarget = target;
            var xStack = new Stack<IType>();

            while (declaring != null)
            {
                xStack.Push(declaring);
                declaring = declaring.Parent;
            }
            var yStack = new Stack<IType>();

            while (target != null)
            {
                yStack.Push(target);
                target = target.Parent;
            }
            int lim = Math.Min(xStack.Count, yStack.Count);
            for (int i = 0; i < lim; i++)
            {
                declaring = xStack.Peek();
                target = yStack.Pop();
                if (!ReferenceEquals(target, declaring))
                {
                    // special-case: if both are the package (file), and they have the same namespace: we're OK
                    if (target is FileDescriptorProto targetFDP && declaring is FileDescriptorProto declaringFDP
                        && normalizer.GetName(declaringFDP) == normalizer.GetName(targetFDP))
                    {
                        // that's fine, keep going
                    }
                    else
                    {
                        // put it back
                        yStack.Push(target);
                        break;
                    }
                }
            }
            // if we used everything, then the target is an ancestor-or-self
            if (yStack.Count == 0)
            {
                target = origTarget;
                if (target is DescriptorProto message) return Escape(normalizer.GetName(message));
                if (target is EnumDescriptorProto @enum) return Escape(normalizer.GetName(@enum));
                return null;
            }

            var sb = new StringBuilder();
            while (yStack.Count != 0)
            {
                target = yStack.Pop();

                string nextName;
                if (target is FileDescriptorProto file) nextName = normalizer.GetName(file);
                else if (target is DescriptorProto message) nextName = normalizer.GetName(message);
                else if (target is EnumDescriptorProto @enum) nextName = normalizer.GetName(@enum);
                else return null;

                if (!string.IsNullOrWhiteSpace(nextName))
                {
                    if (sb.Length == 0 && target is FileDescriptorProto) sb.Append("global::");
                    else if (sb.Length != 0) sb.Append('.');
                    sb.Append(Escape(nextName));
                }
            }
            return sb.ToString();
        }

        private const string
            WellKnownTypeDouble = ".google.protobuf.DoubleValue",
            WellKnownTypeFloat = ".google.protobuf.FloatValue",
            WellKnownTypeInt64 = ".google.protobuf.Int64Value",
            WellKnownTypeUInt64 = ".google.protobuf.UInt64Value",
            WellKnownTypeInt32 = ".google.protobuf.Int32Value",
            WellKnownTypeUInt32 = ".google.protobuf.UInt32Value",
            WellKnownTypeBool = ".google.protobuf.BoolValue",
            WellKnownTypeString = ".google.protobuf.StringValue",
            WellKnownTypeBytes = ".google.protobuf.BytesValue",
            WellKnownTypeTimestamp = ".google.protobuf.Timestamp",
            WellKnownTypeDuration = ".google.protobuf.Duration",
            WellKnownTypeEmpty = ".google.protobuf.Empty";


        /// <summary>
        /// Emit code preceeding a set of service methods
        /// </summary>
        protected override void WriteServiceHeader(GeneratorContext ctx, ServiceDescriptorProto service, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(service);
            if (ctx.EmitServicesFor(ServiceKinds.Grpc))
            {
                var tw = ctx.Write("[global::ProtoBuf.Grpc.Configuration.Service(@\"");
                tw.Write(service.FullyQualifiedName.TrimStart(ParserContext.Period));
                tw.WriteLine("\")]");
            }
            if (ctx.EmitServicesFor(ServiceKinds.Wcf))
            {
                var tw = ctx.Write("[global::System.ServiceModel.ServiceContract(Name = @\"");
                tw.Write(service.FullyQualifiedName.TrimStart(ParserContext.Period));
                tw.WriteLine("\")]");
            }
            WriteOptions(ctx, service.Options);
            ctx.WriteLine($"{GetAccess(GetAccess(service))} partial interface {Escape(name)}").WriteLine("{").Indent();
        }

        /// <summary>
        /// Emit code following a set of service methods
        /// </summary>
        protected override void WriteServiceFooter(GeneratorContext ctx, ServiceDescriptorProto service, ref object state)
        {
            ctx.Outdent().WriteLine("}").WriteLine();
        }

        /// <summary>
        /// Emit code representing a service method
        /// </summary>
        protected override void WriteServiceMethod(GeneratorContext ctx, MethodDescriptorProto method, ref object state)
        {
            var name = ctx.NameNormalizer.GetName(method);
            if (name != method.Name)
            {
                if (ctx.EmitServicesFor(ServiceKinds.Grpc))
                {
                    ctx.WriteLine($@"[global::ProtoBuf.Grpc.Configuration.Operation(@""{method.Name}"")]");
                }
                if (ctx.EmitServicesFor(ServiceKinds.Wcf))
                {
                    ctx.WriteLine($@"[global::System.ServiceModel.OperationContract(Name = @""{method.Name}"")]");
                }
            }
            WriteOptions(ctx, method.Options);

            string returnType, inputType;
            if (method.ServerStreaming)
            {
                returnType = "global::System.Collections.Generic.IAsyncEnumerable<" + GetTypeName(ctx, method.OutputType) + ">";
            }
            else
            {
                if (method.OutputType == WellKnownTypeEmpty)
                {
                    returnType = "global::System.Threading.Tasks.ValueTask";
                }
                else
                {
                    returnType = "global::System.Threading.Tasks.ValueTask<" + GetTypeName(ctx, method.OutputType) + ">";
                }
            }
            if (method.ClientStreaming)
            {
                inputType = "global::System.Collections.Generic.IAsyncEnumerable<" + GetTypeName(ctx, method.InputType) + ">"; 
            }
            else
            {
                if (method.InputType == WellKnownTypeEmpty)
                {
                    inputType = null;
                }
                else
                {
                    inputType = GetTypeName(ctx, method.InputType);
                }
            }

            var tw = ctx.Write($"{returnType} {Escape(name)}Async(");
            if (inputType != null)
            {
                tw.Write(inputType);
                tw.Write(method.ClientStreaming ? " values, " : " value, ");
            }
            tw.Write("global::ProtoBuf.Grpc.CallContext context");
            if (ctx.Supports(CSharp4))
            {
                tw.Write(" = default");
                if (!ctx.Supports(CSharp7_1))
                {
                    tw.Write("(global::ProtoBuf.Grpc.CallContext)");
                }
            }
            tw.WriteLine(");");
        }
    }
}
