using ProtoBuf.Internal.CodeGen;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace ProtoBuf.Reflection.Internal.CodeGen;

/// <summary>
/// A code generator that writes C#
/// </summary>
internal partial class CodeGenCSharpCodeGenerator : CodeGenCommonCodeGenerator
{
    /// <summary>
    /// Reusable code-generator instance
    /// </summary>
    public static CodeGenCSharpCodeGenerator Default { get; } = new CodeGenCSharpCodeGenerator();
    /// <summary>
    /// Create a new CSharpCodeGenerator instance
    /// </summary>
    protected CodeGenCSharpCodeGenerator() { }
    /// <summary>
    /// Returns the language name
    /// </summary>
    public override string Name => "C#";
    /// <summary>
    /// Returns the default file extension
    /// </summary>
    protected override string DefaultFileExtension => "cs";
    /// <summary>
    /// Escapes language keywords
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0066:Convert switch statement to expression", Justification = "Readability")]
    protected override string Escape(string identifier)
    {
        switch (identifier)
        {
            case "abstract":
            case "event":
            case "new":
            case "struct":
            case "as":
            case "explicit":
            case "null":
            case "switch":
            case "base":
            case "extern":
            case "object":
            case "this":
            case "bool":
            case "false":
            case "operator":
            case "throw":
            case "break":
            case "finally":
            case "out":
            case "true":
            case "byte":
            case "fixed":
            case "override":
            case "try":
            case "case":
            case "float":
            case "params":
            case "typeof":
            case "catch":
            case "for":
            case "private":
            case "uint":
            case "char":
            case "foreach":
            case "protected":
            case "ulong":
            case "checked":
            case "goto":
            case "public":
            case "unchecked":
            case "class":
            case "if":
            case "readonly":
            case "unsafe":
            case "const":
            case "implicit":
            case "ref":
            case "ushort":
            case "continue":
            case "in":
            case "return":
            case "using":
            case "decimal":
            case "int":
            case "sbyte":
            case "virtual":
            case "default":
            case "interface":
            case "sealed":
            case "volatile":
            case "delegate":
            case "internal":
            case "short":
            case "void":
            case "do":
            case "is":
            case "sizeof":
            case "while":
            case "double":
            case "lock":
            case "stackalloc":
            case "else":
            case "long":
            case "static":
            case "enum":
            case "namespace":
            case "string":
                return "@" + identifier;
            default:
                return identifier;
        }
    }

    ///// <summary>
    ///// Get the language version for this language from a schema
    ///// </summary>
    //protected override string GetLanguageVersion(CodeGenFile obj)
    //    => obj?.Options?.GetOptions()?.CSharpLanguageVersion;

    private const string AdditionalSuppressionCodes = ", IDE0079, IDE1006, RCS1036, RCS1057, RCS1085, RCS1192";

    /// <summary>
    /// Start a file
    /// </summary>
    protected override void WriteFileHeader(CodeGenGeneratorContext ctx, CodeGenFile file, ref object state)
    {
        var prefix = ctx.Supports(CSharp6) ? "CS" : "";
        var tw = ctx.WriteLine("// <auto-generated>")
           .WriteLine("//   This file was generated by a tool; you should avoid making direct changes.")
           .WriteLine("//   Consider using 'partial classes' to extend these types")
           .WriteLine($"//   Input: {Path.GetFileName(ctx.File.Name)}")
           .WriteLine("// </auto-generated>")
           .WriteLine()
           .WriteLine("#region Designer generated code")
           .Write($"#pragma warning disable {prefix}0612, {prefix}0618, {prefix}1591, {prefix}3021");
        if (ctx.Supports(CSharp6))
        {
            tw.Write(AdditionalSuppressionCodes);
        }
        tw.WriteLine();
    }

    /// <inheritdoc/>
    protected override void WriteNamespaceHeader(CodeGenGeneratorContext ctx, string @namespace)
    {
        if (!string.IsNullOrEmpty(@namespace))
        {
            ctx.WriteLine($"namespace {@namespace.TrimEnd('.')}");    
        }

        ctx.WriteLine("{").Indent().WriteLine();
    }

    /// <inheritdoc/>
    protected override void WriteNamespaceFooter(CodeGenGeneratorContext ctx, string @namespace)
    {
        ctx.Outdent().WriteLine("}").WriteLine();
    }

    /// <summary>
    /// End a file
    /// </summary>
    protected override void WriteFileFooter(CodeGenGeneratorContext ctx, CodeGenFile file, ref object state)
    {
        var prefix = ctx.Supports(CSharp6) ? "CS" : "";
        var tw = ctx.Write($"#pragma warning restore {prefix}0612, {prefix}0618, {prefix}1591, {prefix}3021");
        if (ctx.Supports(CSharp6))
        {
            tw.Write(AdditionalSuppressionCodes);
        }
        tw.WriteLine();
        tw.WriteLine("#endregion");
    }
    /// <summary>
    /// Start an enum
    /// </summary>
    protected override void WriteEnumHeader(CodeGenGeneratorContext ctx, CodeGenEnum @enum, ref object state)
    {
        var tw = ctx.Write("[global::ProtoBuf.ProtoContract(");
        if (@enum.ShouldSerializeOriginalName()) tw.Write($@"Name = @""{@enum.OriginalName}""");
        tw.WriteLine(")]");
        if (@enum.IsDeprecated) WriteDeprecated(ctx);
        ctx.WriteLine($"{GetAccess(@enum.Access)} enum {Escape(@enum.Name)}").WriteLine("{").Indent();
    }
    /// <summary>
    /// End an enum
    /// </summary>
    
    /// <summary>
    /// Start an enum value
    /// </summary>
    protected override void WriteEnumValue(CodeGenGeneratorContext ctx, CodeGenEnumValue enumValue, ref object state)
    {
        var tw = ctx.Write("[global::ProtoBuf.ProtoEnum(");
        if (enumValue.ShouldSerializeOriginalName()) tw.Write($@"Name = @""{enumValue.OriginalName}""");
        tw.WriteLine(")]");
        ctx.WriteLine($"{Escape(enumValue.Name)} = {enumValue.Value},");
    }
    /// <summary>
    /// End an enum value
    /// </summary>

    protected override void WriteEnumFooter(CodeGenGeneratorContext ctx, CodeGenEnum @enum, ref object state)
    {
        ctx.Outdent().WriteLine("}").WriteLine();
    }

    protected override void WriteServiceHeader(CodeGenGeneratorContext ctx, CodeGenService service, ref object state)
    {
        var tw = ctx.Write("[global::System.ServiceModel.ServiceContract(");
        if (service.ShouldSerializeOriginalName()) tw.Write($@"Name = @""{service.OriginalName}""");
        tw.WriteLine(")]");
        // if (message.IsDeprecated) WriteDeprecated(ctx);
        ctx.WriteLine($"{GetAccess(service.Access)} partial interface I{Escape(service.Name)}");
        ctx.WriteLine("{").Indent();
    }

    protected override void WriteServiceMethod(CodeGenGeneratorContext ctx, CodeGenServiceMethod method, ref object state)
    {
        ctx.WriteLine($"{method.Response} {method.Name}Async({method.Request} value, global::ProtoBuf.Grpc.CallContext context = default);");
        ctx.WriteLine();
    }
    
    protected override void WriteServiceFooter(CodeGenGeneratorContext ctx, CodeGenService service, ref object state)
    {
        ctx.Outdent().WriteLine("}").WriteLine();
    }
    
    ///// <summary>
    ///// Write an enum value
    ///// </summary>
    //protected override void WriteEnumValue(CodeGenGeneratorContext ctx, EnumValueDescriptorProto @enum, ref object state)
    //{
    //    var name = ctx.NameNormalizer.GetName(@enum);
    //    if (name != @enum.Name)
    //    {
    //        var tw = ctx.Write("[global::ProtoBuf.ProtoEnum(");
    //        tw.Write($@"Name = @""{@enum.Name}""");
    //        tw.WriteLine(")]");
    //    }

    //    WriteOptions(ctx, @enum.Options);
    //    ctx.WriteLine($"{Escape(name)} = {@enum.Number},");
    //}

    /// <summary>
    /// End a message
    /// </summary>
    protected override void WriteMessageFooter(CodeGenGeneratorContext ctx, CodeGenMessage message, ref object state)
    {
        //if (UsePooledMemory(ctx, message))
        //{
        //    ctx.Write("public virtual void Dispose()").WriteLine();
        //    ctx.WriteLine("{").Indent();
        //    bool first = true;
        //    foreach (var field in message.Fields)
        //    {
        //        if (field.type == FieldDescriptorProto.Type.TypeBytes)
        //        {
        //            var member = Escape(ctx.NameNormalizer.GetName(field));
        //            ctx.WriteLine($"{(first ? "var " : "")}__oldMemory = {member};");
        //            ctx.WriteLine($"{member} = default{(ctx.Supports(CSharp7_1) ? "" : "(global::ProtoBuf.PooledMemory<byte>)")};");
        //            ctx.WriteLine("__oldMemory.Dispose();");
        //            first = false;
        //        }
        //    }
        //    ctx.WriteLine("OnDispose(); // invoke user-defined additional dispose features, if any");
        //    ctx.Outdent().WriteLine("}").WriteLine("partial void OnDispose(); // implement in a partial class to add additional dispose features").WriteLine();
        //}
        ctx.Outdent().WriteLine("}").WriteLine();
    }
    /// <summary>
    /// Start a message
    /// </summary>
    protected override void WriteMessageHeader(CodeGenGeneratorContext ctx, CodeGenMessage message, ref object state)
    {
        var tw = ctx.Write("[global::ProtoBuf.ProtoContract(");
        if (message.ShouldSerializeOriginalName()) tw.Write($@"Name = @""{message.OriginalName}""");
        tw.WriteLine(")]");
        if (message.IsDeprecated) WriteDeprecated(ctx);
        tw = ctx.Write($"{GetAccess(message.Access)} partial class {Escape(message.Name)}");
        tw.Write(" : global::ProtoBuf.IExtensible");
        //if (UsePooledMemory(ctx, message))
        //{
        //    tw.Write(", global::System.IDisposable");
        //}
        tw.WriteLine();
        ctx.WriteLine("{").Indent();
        //if (message.Options?.MessageSetWireFormat == true)
        //{
        //    ctx.WriteLine("#error message_set_wire_format is not currently implemented").WriteLine();
        //}

        ctx.WriteLine($"private global::ProtoBuf.IExtension {FieldPrefix}extensionData;")
            .WriteLine($"global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)");

        if (ctx.Supports(CSharp6))
        {
            ctx.Indent().WriteLine($"=> global::ProtoBuf.Extensible.GetExtensionObject(ref {FieldPrefix}extensionData, createIfMissing);").Outdent().WriteLine();
        }
        else
        {
            ctx.WriteLine("{").Indent().WriteLine($"return global::ProtoBuf.Extensible.GetExtensionObject(ref {FieldPrefix}extensionData, createIfMissing);").Outdent().WriteLine("}");
        }
    }

    protected static void WriteDeprecated(CodeGenGeneratorContext ctx)
        => ctx.WriteLine($"[global::System.Obsolete]");

    private const string FieldPrefix = "__pbn__";

    /// <summary>
    /// Get the language specific keyword representing an access level
    /// </summary>
    public override string GetAccess(Access access)
    {
        return access switch
        {
            Access.Internal => "internal",
            Access.Public => "public",
            Access.Private => "private",
            _ => base.GetAccess(access),
        };
    }

    /// <summary>
    /// Emit code beginning a constructor, if one is required
    /// </summary>
    /// <returns>true if a constructor is required</returns>
    protected override bool WriteContructorHeader(CodeGenGeneratorContext ctx, CodeGenMessage message, ref object state)
    {
        if (ctx.Supports(CSharp6)) return false;

        ctx.WriteLine($"public {Escape(message.Name)}()") // note: the .ctor is still public even if the type is internal; it is protected by the scope
            .WriteLine("{").Indent();
        return true;
    }

    /// <summary>
    /// Emit code terminating a constructor, if one is required
    /// </summary>
    protected override void WriteConstructorFooter(CodeGenGeneratorContext ctx, CodeGenMessage message, ref object state)
    {
        if (ctx.Supports(CSharp3))
        {
            ctx.WriteLine("OnConstructor();");
        }
        ctx.Outdent().WriteLine("}").WriteLine();

        if (ctx.Supports(CSharp3))
        {
            ctx.WriteLine("partial void OnConstructor();")
            .WriteLine();
        }
    }

    /// <summary>
    /// Emit code initializing field values inside a constructor, if one is required
    /// </summary>
    protected override void WriteInitField(CodeGenGeneratorContext ctx, CodeGenField field, ref object state)
    {
        string defaultValue = null; // GetDefaultValue(ctx, field, typeName);

        if (field.IsRepeated)
        {
            if (field.Type is CodeGenMapEntryType mapMsgType)
            {
                var keyTypeName = GetEscapedTypeName(ctx, mapMsgType.KeyType, out _);
                var valueTypeName = GetEscapedTypeName(ctx, mapMsgType.ValueType, out _);
                ctx.WriteLine($"{Escape(field.BackingName)} = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>();");
            }
            else if (!UseArray(field.Type))
            {
                ctx.WriteLine($"{Escape(field.BackingName)} = new global::System.Collections.Generic.List<{GetEscapedTypeName(ctx, field.Type, out _)}>();");
            }
        }
        else if (!field.TrackFieldPresence)
        {
            if (!string.IsNullOrWhiteSpace(defaultValue))
            {
                ctx.WriteLine($"{Escape(field.BackingName)} = {defaultValue};");
            }
        }
    }

    //private string GetDefaultValue(CodeGenGeneratorContext ctx, CodeGenField obj, string typeName)
    //{
    //    string defaultValue = null;
    //    bool isOptional = obj.label == FieldDescriptorProto.Label.LabelOptional;

    //    if (isOptional || ctx.EmitRequiredDefaults || obj.type == FieldDescriptorProto.Type.TypeEnum)
    //    {
    //        defaultValue = obj.DefaultValue;

    //        if (obj.type == FieldDescriptorProto.Type.TypeString)
    //        {
    //            defaultValue = string.IsNullOrEmpty(defaultValue) ? "\"\""
    //                : ("@\"" + (defaultValue ?? "").Replace("\"", "\"\"") + "\"");
    //        }
    //        else if (obj.type == FieldDescriptorProto.Type.TypeDouble)
    //        {
    //            switch (defaultValue)
    //            {
    //                case "inf": defaultValue = "double.PositiveInfinity"; break;
    //                case "-inf": defaultValue = "double.NegativeInfinity"; break;
    //                case "nan": defaultValue = "double.NaN"; break;
    //            }
    //        }
    //        else if (obj.type == FieldDescriptorProto.Type.TypeFloat)
    //        {
    //            switch (defaultValue)
    //            {
    //                case "inf": defaultValue = "float.PositiveInfinity"; break;
    //                case "-inf": defaultValue = "float.NegativeInfinity"; break;
    //                case "nan": defaultValue = "float.NaN"; break;
    //            }
    //        }
    //        else if (obj.type == FieldDescriptorProto.Type.TypeEnum)
    //        {
    //            var enumType = ctx.TryFind<EnumDescriptorProto>(obj.TypeName);
    //            if (enumType != null)
    //            {
    //                EnumValueDescriptorProto found = null;
    //                if (!string.IsNullOrEmpty(defaultValue))
    //                {
    //                    found = enumType.Values.Find(x => x.Name == defaultValue);
    //                }
    //                else if (ctx.Syntax == FileDescriptorProto.SyntaxProto2)
    //                {
    //                    // find the first one; if that is a zero, we don't need it after all
    //                    found = enumType.Values.FirstOrDefault();
    //                    if (found != null && found.Number == 0)
    //                    {
    //                        if (!isOptional) found = null; // we don't need it after all
    //                    }
    //                }
    //                // for proto3 the default is 0, so no need to do anything - GetValueOrDefault() will do it all

    //                if (found != null)
    //                {
    //                    defaultValue = ctx.NameNormalizer.GetName(found);
    //                }
    //                if (!string.IsNullOrWhiteSpace(defaultValue))
    //                {
    //                    defaultValue = typeName + "." + defaultValue;
    //                }
    //            }
    //        }
    //    }

    //    return defaultValue;
    //}
    /// <summary>
    /// Write a field
    /// </summary>
    protected override void WriteField(CodeGenGeneratorContext ctx, CodeGenField field, ref object state)
    {
        var tw = ctx.Write($"[global::ProtoBuf.ProtoMember({field.FieldNumber}");
        if (field.ShouldSerializeOriginalName())
        {
            tw.Write($@", Name = @""{field.OriginalName}""");
        }

        if (field.AsReference)
        {
            tw.Write(", AsReference = true");
        }
        if (field.AsDynamicType)
        {
            tw.Write(", DynamicType = true");
        }

        bool suppressDefaultAttribute = field.IsRequired;
        var typeName = GetEscapedTypeName(ctx, field.Type, out var dataFormat);
        string defaultValue = null; // GetDefaultValue(ctx, field, typeName);

        if (dataFormat.HasValue)
        {
            tw.Write($", DataFormat = global::ProtoBuf.DataFormat.{dataFormat}");
        }
        if (field.IsPacked)
        {
            tw.Write($", IsPacked = true");
        }
        if (field.IsRequired)
        {
            tw.Write($", IsRequired = true");
        }
        tw.WriteLine(")]");
        if (!field.IsRepeated && !string.IsNullOrWhiteSpace(defaultValue) && !suppressDefaultAttribute)
        {
            if (field.Type.IsWellKnownType(out var found) && (found == CodeGenWellKnownType.Fixed64 || found == CodeGenWellKnownType.UInt64))
            {
                ctx.WriteLine($"[global::System.ComponentModel.DefaultValue(typeof(ulong), \"{defaultValue}\")]");
            }
            else
            {
                ctx.WriteLine($"[global::System.ComponentModel.DefaultValue({defaultValue})]");
            }
        }
        if (field.IsDeprecated) WriteDeprecated(ctx);
        var escapedName = Escape(field.Name);
        if (field.IsRepeated)
        {
            bool allowSet = ctx.EmitListSetters;
            if (field.Type is CodeGenMapEntryType mapMsgType)
            {
                var keyTypeName = GetEscapedTypeName(ctx, mapMsgType.KeyType, out var keyDataFormat);
                var valueTypeName = GetEscapedTypeName(ctx, mapMsgType.ValueType, out var valueDataFormat);

                bool first = true;
                tw = ctx.Write($"[global::ProtoBuf.ProtoMap");
                if (keyDataFormat.HasValue)
                {
                    tw.Write($"{(first ? "(" : ", ")}KeyFormat = global::ProtoBuf.DataFormat.{keyDataFormat}");
                    first = false;
                }
                if (valueDataFormat.HasValue)
                {
                    tw.Write($"{(first ? "(" : ", ")}ValueFormat = global::ProtoBuf.DataFormat.{valueDataFormat}");
                    first = false;
                }
                tw.WriteLine(first ? "]" : ")]");
                if (ctx.Supports(CSharp6))
                {
                    ctx.WriteLine($"{GetAccess(field.Access)} global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}> {escapedName} {{ get; {(allowSet ? "set; " : "")}}} = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>();");
                }
                else
                {
                    ctx.WriteLine($"{GetAccess(field.Access)} global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}> {escapedName} {{ get; {(allowSet ? "" : "private ")}set; }}");
                }
            }
            else if (UseArray(field.Type))
            {
                ctx.WriteLine($"{GetAccess(field.Access)} {typeName}[] {escapedName} {{ get; set; }}");
            }
            else if (ctx.Supports(CSharp6))
            {
                ctx.WriteLine($"{GetAccess(field.Access)} global::System.Collections.Generic.List<{typeName}> {escapedName} {{ get; {(allowSet ? "set; " : "")}}} = new global::System.Collections.Generic.List<{typeName}>();");
            }
            else
            {
                ctx.WriteLine($"{GetAccess(field.Access)} global::System.Collections.Generic.List<{typeName}> {escapedName} {{ get; {(allowSet ? "" : "private ")}set; }}");
            }
        }
        //else if (oneOf is object)
        //{
        //    var defValue = string.IsNullOrWhiteSpace(defaultValue) ? (ctx.Supports(CSharp7_1) ? "default" : $"default({typeName})") : defaultValue;
        //    var fieldName = GetOneOfFieldName(oneOf.OneOf);
        //    var storage = oneOf.GetStorage(field.type, field.TypeName);
        //    ctx.WriteLine($"{GetAccess(GetAccess(field))} {typeName} {Escape(name)}").WriteLine("{").Indent();

        //    switch (field.type)
        //    {
        //        case FieldDescriptorProto.Type.TypeMessage:
        //        case FieldDescriptorProto.Type.TypeGroup:
        //        case FieldDescriptorProto.Type.TypeEnum:
        //        case FieldDescriptorProto.Type.TypeBytes:
        //        case FieldDescriptorProto.Type.TypeString:
        //            ctx.WriteLine($"{PropGetPrefix()}{fieldName}.Is({field.Number}) ? (({typeName}){fieldName}.{storage}) : {defValue};{PropSuffix()}");
        //            break;
        //        default:
        //            ctx.WriteLine($"{PropGetPrefix()}{fieldName}.Is({field.Number}) ? {fieldName}.{storage} : {defValue};{PropSuffix()}");
        //            break;
        //    }
        //    var unionType = oneOf.GetUnionType();
        //    var cast = field.type == FieldDescriptorProto.Type.TypeEnum ? "(int)" : "";
        //    ctx.WriteLine($"{PropSetPrefix()}{fieldName} = new global::ProtoBuf.{unionType}({field.Number}, {cast}value);{PropSuffix()}")
        //        .Outdent().WriteLine("}");

        //    if (ctx.Supports(CSharp6))
        //    {
        //        ctx.WriteLine($"{GetAccess(GetAccess(field))} bool ShouldSerialize{name}() => {fieldName}.Is({field.Number});")
        //        .WriteLine($"{GetAccess(GetAccess(field))} void Reset{name}() => global::ProtoBuf.{unionType}.Reset(ref {fieldName}, {field.Number});");
        //    }
        //    else
        //    {
        //        ctx.WriteLine($"{GetAccess(GetAccess(field))} bool ShouldSerialize{name}()").WriteLine("{").Indent()
        //            .WriteLine($"return {fieldName}.Is({field.Number});").Outdent().WriteLine("}")
        //            .WriteLine($"{GetAccess(GetAccess(field))} void Reset{name}()").WriteLine("{").Indent()
        //            .WriteLine($"global::ProtoBuf.{unionType}.Reset(ref {fieldName}, {field.Number});").Outdent().WriteLine("}");
        //    }

        //    if (oneOf.IsFirst())
        //    {
        //        ctx.WriteLine().WriteLine($"private global::ProtoBuf.{unionType} {fieldName};");
        //    }
        //}
        else if (field.TrackFieldPresence)
        {
            string fieldName = FieldPrefix + escapedName, fieldType;
            bool isRef = false;
            if (field.Type.IsWellKnownType(out var known) && (known == CodeGenWellKnownType.String || known == CodeGenWellKnownType.Bytes))
            {
                fieldType = typeName;
                isRef = true;
            }
            else
            {
                fieldType = typeName + "?";
            }

            ctx.WriteLine($"{GetAccess(field.Access)} {typeName} {escapedName}").WriteLine("{").Indent();
            tw = ctx.Write(PropGetPrefix());
            tw.Write(fieldName);
            if (!string.IsNullOrWhiteSpace(defaultValue))
            {
                tw.Write(" ?? ");
                tw.Write(defaultValue);
            }
            else if (!isRef)
            {
                tw.Write(".GetValueOrDefault()");
            }
            tw.Write(";");
            tw.WriteLine(PropSuffix());

            ctx.WriteLine($"{PropSetPrefix()}{fieldName} = value;{PropSuffix()}")
                .Outdent().WriteLine("}");
            if (ctx.Supports(CSharp6))
            {
                ctx.WriteLine($"{GetAccess(field.Access)} bool ShouldSerialize{escapedName}() => {fieldName} != null;")
                .WriteLine($"{GetAccess(field.Access)} void Reset{escapedName}() => {fieldName} = null;");
            }
            else
            {
                ctx.WriteLine($"{GetAccess(field.Access)} bool ShouldSerialize{escapedName}()").WriteLine("{").Indent()
                    .WriteLine($"return {fieldName} != null;").Outdent().WriteLine("}")
                    .WriteLine($"{GetAccess(field.Access)} void Reset{escapedName}()").WriteLine("{").Indent()
                    .WriteLine($"{fieldName} = null;").Outdent().WriteLine("}");
            }
            ctx.WriteLine($"private {fieldType} {fieldName};");
        }
        else
        {
            tw = ctx.Write($"{GetAccess(field.Access)} {typeName} {escapedName} {{ get; set; }}");
            if (!string.IsNullOrWhiteSpace(defaultValue) && ctx.Supports(CSharp6)) tw.Write($" = {defaultValue};");
            tw.WriteLine();
        }
        ctx.WriteLine();

        string PropGetPrefix() => ctx.Supports(CSharp7) ? "get => " : "get { return ";
        string PropSetPrefix() => ctx.Supports(CSharp7) ? "set => " : "set { ";
        string PropSuffix() => ctx.Supports(CSharp7) ? "" : " }";
    }

    //private static string GetOneOfFieldName(OneofDescriptorProto obj) => FieldPrefix + obj.Name;

    private static readonly Version // note: only mentioning features we use
        CSharp3 = new Version(3, 0), // partial methods
        CSharp4 = new Version(4, 0), // optional parameters
        CSharp6 = new Version(6, 0), // pragma prefixes, method expressions, property initializers
        CSharp7 = new Version(7, 0), // property expressions
        CSharp7_1 = new Version(7, 1); // default literals

    ///// <summary>
    ///// Starts an extensions block
    ///// </summary>
    //protected override void WriteExtensionsHeader(CodeGenGeneratorContext ctx, CodeGenFile file, ref object state)
    //{
    //    var name = file?.Options?.GetOptions()?.ExtensionTypeName;
    //    if (string.IsNullOrWhiteSpace(name)) name = "Extensions";
    //    ctx.WriteLine($"{GetAccess(GetAccess(file))} static partial class {Escape(name)}").WriteLine("{").Indent();
    //}
    ///// <summary>
    ///// Ends an extgensions block
    ///// </summary>
    //protected override void WriteExtensionsFooter(CodeGenGeneratorContext ctx, CodeGenFile file, ref object state)
    //{
    //    ctx.Outdent().WriteLine("}");
    //}
    ///// <summary>
    ///// Starts an extensions block
    ///// </summary>
    //protected override void WriteExtensionsHeader(CodeGenGeneratorContext ctx, CodeGenMessage message, ref object state)
    //{
    //    var name = message?.Options?.GetOptions()?.ExtensionTypeName;
    //    if (string.IsNullOrWhiteSpace(name)) name = "Extensions";
    //    ctx.WriteLine($"{GetAccess(GetAccess(message))} static partial class {Escape(name)}").WriteLine("{").Indent();
    //}
    ///// <summary>
    ///// Ends an extensions block
    ///// </summary>
    //protected override void WriteExtensionsFooter(CodeGenGeneratorContext ctx, CodeGenMessage message, ref object state)
    //{
    //    ctx.Outdent().WriteLine("}");
    //}
    ///// <summary>
    ///// Write an extension
    ///// </summary>
    //protected override void WriteExtension(CodeGenGeneratorContext ctx, FieldDescriptorProto field)
    //{
    //    var type = GetTypeName(ctx, field, out string dataFormat, out bool isMap, false);
    //    var nonNullableType = GetTypeName(ctx, field, out _, out _, true);
    //    var msg = ctx.TryFind<DescriptorProto>(field.Extendee);
    //    var extendee = MakeRelativeName(field, msg, ctx.NameNormalizer);

    //    var @this = field.Parent is FileDescriptorProto ? "this " : "";
    //    string name = ctx.NameNormalizer.GetName(field);
    //    TextWriter tw;

    //    if (isMap)
    //    {
    //        ctx.WriteLine("#error map extensions not yet implemented; please file an issue");
    //    }
    //    else
    //    {
    //        bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;

    //        var getMethodName = isRepeated ? nameof(Extensible.GetValues) : nameof(Extensible.GetValue);
    //        if(isRepeated) ctx.WriteLine($"{GetAccess(GetAccess(field))} static global::System.Collections.Generic.IEnumerable<{nonNullableType}> Get{name}({@this}{extendee} obj)");
    //        else ctx.WriteLine($"{GetAccess(GetAccess(field))} static {type} Get{name}({@this}{extendee} obj)");
    //        if (ctx.Supports(CSharp6))
    //        {
    //            tw = ctx.Indent().Write($"=> ");
    //        }
    //        else
    //        {
    //            ctx.WriteLine("{").Indent();
    //            tw = ctx.Write("return ");
    //        }
    //        var defaultValue = isRepeated ? "null" : ctx.Supports(CSharp7_1) ? "default" : $"default({type})";
    //        tw.Write($"obj == null ? {defaultValue} : global::ProtoBuf.Extensible.{getMethodName}<{(isRepeated ? nonNullableType : type)}>(obj, {field.Number}");
    //        if (!string.IsNullOrEmpty(dataFormat))
    //        {
    //            tw.Write($", global::ProtoBuf.DataFormat.{dataFormat}");
    //        }
    //        tw.WriteLine(");");
    //        if (ctx.Supports(CSharp6)) ctx.Outdent().WriteLine();
    //        else ctx.Outdent().WriteLine("}").WriteLine();

    //        var setAccessorName = isRepeated ? "Add" : "Set";
    //        ctx.WriteLine($"{GetAccess(GetAccess(field))} static void {setAccessorName}{name}({@this}{extendee} obj, {nonNullableType} value)");
    //        if (ctx.Supports(CSharp6))
    //        {
    //            tw = ctx.Indent().Write($"=> ");
    //        }
    //        else
    //        {
    //            ctx.WriteLine("{").Indent();
    //            tw = ctx.Write("");
    //        }
    //        tw.Write($"global::ProtoBuf.Extensible.AppendValue<{nonNullableType}>(obj, {field.Number}");
    //        if (!string.IsNullOrEmpty(dataFormat))
    //        {
    //            tw.Write($", global::ProtoBuf.DataFormat.{dataFormat}");
    //        }
    //        tw.WriteLine(", value);");
    //        if (ctx.Supports(CSharp6)) ctx.Outdent().WriteLine();
    //        else ctx.Outdent().WriteLine("}").WriteLine();
    //    }
    //}

    ///// <summary>
    ///// Emit the start of an enum declaration for 'oneof' groups, including the 0/None element
    ///// </summary>
    //protected override void WriteOneOfEnumHeader(CodeGenGeneratorContext ctx, OneofDescriptorProto oneof, ref object state)
    //{
    //    ctx.WriteLine().WriteLine($"public enum {ctx.NameNormalizer.GetName(oneof)}{OneOfEnumSuffixEnum}").WriteLine("{").Indent().WriteLine("None = 0,");
    //}
    ///// <summary>
    ///// Emit the end of an enum declaration for 'oneof' groups
    ///// </summary>
    //protected override void WriteOneOfEnumFooter(CodeGenGeneratorContext ctx, OneofDescriptorProto oneof, ref object state)
    //{
    //    ctx.Outdent().WriteLine("}").WriteLine();
    //}

    ///// <summary>
    ///// Emit a field-based entry for a 'oneof' groups's enum
    ///// </summary>
    //protected override void WriteOneOfEnumValue(CodeGenGeneratorContext ctx, FieldDescriptorProto field, ref object state)
    //{
    //    var name = ctx.NameNormalizer.GetName(field);
    //    ctx.WriteLine($"{Escape(name)} = {field.Number},");
    //}
    ///// <summary>
    ///// Emit  the discriminator accessor for 'oneof' groups
    ///// </summary>
    //protected override void WriteOneOfDiscriminator(CodeGenGeneratorContext ctx, OneofDescriptorProto oneof, ref object state)
    //{
    //    var name = ctx.NameNormalizer.GetName(oneof);
    //    var fieldName = GetOneOfFieldName(oneof);
    //    if (ctx.Supports(CSharp6))
    //    {
    //        ctx.WriteLine($"public {name}{OneOfEnumSuffixEnum} {name}{OneOfEnumSuffixDiscriminator} => ({name}{OneOfEnumSuffixEnum}){fieldName}.Discriminator;");
    //    }
    //    else
    //    {
    //        ctx.WriteLine($"public {name}{OneOfEnumSuffixEnum} {name}{OneOfEnumSuffixDiscriminator}").WriteLine("{").Indent()
    //            .WriteLine($"get {{ return ({name}{OneOfEnumSuffixEnum}){fieldName}.Discriminator; }}")
    //            .Outdent().WriteLine("}");
    //    }
    //}

    /// <summary>
    /// Indicate which types will commonly use arrays
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0066:Convert switch statement to expression", Justification = "Readability")]
    protected virtual bool UseArray(CodeGenType type)
    {
        if (type.IsWellKnownType(out var known))
        {
            switch (known)
            {
                case CodeGenWellKnownType.String:
                //case FieldDescriptorProto.Type.TypeBool:
                //case FieldDescriptorProto.Type.TypeDouble:
                //case FieldDescriptorProto.Type.TypeFixed32:
                //case FieldDescriptorProto.Type.TypeFixed64:
                //case FieldDescriptorProto.Type.TypeFloat:
                //case FieldDescriptorProto.Type.TypeInt32:
                //case FieldDescriptorProto.Type.TypeInt64:
                //case FieldDescriptorProto.Type.TypeSfixed32:
                //case FieldDescriptorProto.Type.TypeSfixed64:
                //case FieldDescriptorProto.Type.TypeSint32:
                //case FieldDescriptorProto.Type.TypeSint64:
                //case FieldDescriptorProto.Type.TypeUint32:
                //case FieldDescriptorProto.Type.TypeUint64:
                    return true;
            }
        }
        return false;
    }

    ///// <summary>
    ///// Obtain a relative name from a type name
    ///// </summary>
    //protected string MakeRelativeName(CodeGenGeneratorContext ctx, string typeName)
    //{
    //    var target = ctx.TryFind<DescriptorProto>(typeName);
    //    if (target != null && target.Parent is IType type)
    //    {
    //        var name = FindNameFromCommonAncestor(type, target, ctx.NameNormalizer);
    //        if (!string.IsNullOrWhiteSpace(name))
    //        {
    //            return name;
    //        }
    //    }

    //    return Escape(typeName);
    //}

    private static readonly char[] NamespaceSplitTokens = new[] { '.', '+' };
    private string GetEscapedTypeName(CodeGenGeneratorContext ctx, CodeGenType type, out DataFormat? dataFormat)
    {
        dataFormat = null;
        //isMap = false;
        if (type is null) return null;

        if (type.IsWellKnownType(out var known))
        {
            switch (known)
            {
                case CodeGenWellKnownType.Boolean: return "bool";
                case CodeGenWellKnownType.String: return "string";
                case CodeGenWellKnownType.Bytes: return "byte[]";
                case CodeGenWellKnownType.Int64: return "long";
                case CodeGenWellKnownType.Int32: return "int";
                case CodeGenWellKnownType.UInt64: return "ulong";
                case CodeGenWellKnownType.UInt32: return "uint";
                case CodeGenWellKnownType.SInt64:
                    dataFormat = DataFormat.ZigZag;
                    return "long";
                case CodeGenWellKnownType.SInt32:
                    dataFormat = DataFormat.ZigZag;
                    return "int";
                case CodeGenWellKnownType.Float: return "float";
                case CodeGenWellKnownType.Double: return "double";
                case CodeGenWellKnownType.Fixed32:
                    dataFormat = DataFormat.FixedSize;
                    return "uint";
                case CodeGenWellKnownType.SFixed32:
                    dataFormat = DataFormat.FixedSize;
                    return "int";
                case CodeGenWellKnownType.Fixed64:
                    dataFormat = DataFormat.FixedSize;
                    return "ulong";
                case CodeGenWellKnownType.SFixed64:
                    dataFormat = DataFormat.FixedSize;
                    return "long";
                case CodeGenWellKnownType.NetObjectProxy:
                    return "object";
                default:
                    throw new NotImplementedException($"Well known format not handled in {nameof(GetEscapedTypeName)}: {known}");
            }
        }
        //switch (type)
        //{
        //    case CodeGenMessage msg:
        //        isMap = msg.IsMapEntry;
        //        break;

        //}
        var prefix = type.FullyQualifiedPrefix;
        if (string.IsNullOrWhiteSpace(prefix)) return "global::" + Escape(type.Name);

        var index = prefix.IndexOfAny(NamespaceSplitTokens);
        if (index == prefix.Length - 1)
        {
            return "global::" + Escape(prefix.Substring(0, prefix.Length - 1)) + "." + Escape(type.Name);
        }
        
        // the following is not hugely efficient; we could clean up later if we want
        var tokens = prefix.Split(NamespaceSplitTokens);
        var sb = new StringBuilder(prefix.Length + 16);
        sb.Append("global::");
        foreach (var token in tokens)
        {
            if (string.IsNullOrEmpty(token)) continue;
            sb.Append(Escape(token)).Append('.');
        }
        sb.Append(Escape(type.Name));
        return sb.ToString();

        //switch (field.Type)
        //{
        //    case FieldDescriptorProto.Type.TypeDouble:
        //        return "double";
        //    case FieldDescriptorProto.Type.TypeFloat:
        //        return "float";
        //    case FieldDescriptorProto.Type.TypeBool:
        //        return "bool";
        //    case FieldDescriptorProto.Type.TypeString:
        //        return "string";
        //    case FieldDescriptorProto.Type.TypeSint32:
        //        dataFormat = nameof(DataFormat.ZigZag);
        //        return "int";
        //    case FieldDescriptorProto.Type.TypeInt32:
        //        return "int";
        //    case FieldDescriptorProto.Type.TypeSfixed32:
        //        dataFormat = nameof(DataFormat.FixedSize);
        //        return "int";
        //    case FieldDescriptorProto.Type.TypeSint64:
        //        dataFormat = nameof(DataFormat.ZigZag);
        //        return "long";
        //    case FieldDescriptorProto.Type.TypeInt64:
        //        return "long";
        //    case FieldDescriptorProto.Type.TypeSfixed64:
        //        dataFormat = nameof(DataFormat.FixedSize);
        //        return "long";
        //    case FieldDescriptorProto.Type.TypeFixed32:
        //        dataFormat = nameof(DataFormat.FixedSize);
        //        return "uint";
        //    case FieldDescriptorProto.Type.TypeUint32:
        //        return "uint";
        //    case FieldDescriptorProto.Type.TypeFixed64:
        //        dataFormat = nameof(DataFormat.FixedSize);
        //        return "ulong";
        //    case FieldDescriptorProto.Type.TypeUint64:
        //        return "ulong";
        //    case FieldDescriptorProto.Type.TypeBytes:
        //        return UseMemory(ctx) ? "global::System.Memory<byte>" : "byte[]";
        //    case FieldDescriptorProto.Type.TypeEnum:
        //        switch (field.TypeName)
        //        {
        //            case ".bcl.DateTime.DateTimeKind":
        //                return "global::System.DateTimeKind";
        //        }
        //        var enumType = ctx.TryFind<EnumDescriptorProto>(field.TypeName);
        //        return MakeRelativeName(field, enumType, ctx.NameNormalizer);
        //    case FieldDescriptorProto.Type.TypeGroup:
        //    case FieldDescriptorProto.Type.TypeMessage:
        //        return GetTypeName(ctx, field, field.TypeName, ref dataFormat, ref isMap, nonNullable);
        //    default:
        //        return field.TypeName;
        //}
    }

    //private string MakeRelativeName(CodeGenField field, IType target, NameNormalizer normalizer)
    //{
    //    if (target == null) return Escape(field.TypeName); // the only thing we know

    //    switch(target)
    //    {
    //        case DescriptorProto message:
    //            var overrideNs = message.Options?.GetOptions()?.Namespace;
    //            if (!string.IsNullOrWhiteSpace(overrideNs))
    //                return "global::" + overrideNs + "." + Escape(normalizer.GetName(message));
    //            break;
    //        case EnumDescriptorProto @enum:
    //            overrideNs = @enum.Options?.GetOptions()?.Namespace;
    //            if (!string.IsNullOrWhiteSpace(overrideNs))
    //                return "global::" + overrideNs + "." + Escape(normalizer.GetName(@enum));
    //            break;
    //    };

    //    var declaringType = field.Parent;

    //    if (declaringType is IType type)
    //    {
    //        var name = FindNameFromCommonAncestor(type, target, normalizer);
    //        if (!string.IsNullOrWhiteSpace(name)) return name;
    //    }
    //    return Escape(field.TypeName); // give up!
    //}

    // k, what we do is; we have two types; each knows the parent, but nothing else, so:
    // for each, use a stack to build the ancestry tree - the "top" of the stack will be the
    // package, the bottom of the stack will be the type itself. They will often be stacks
    // of different heights.
    //
    // Find how many is in the smallest stack; now take that many items, in turn, until we
    // get something that is different (at which point, put that one back on the stack), or 
    // we run out of items in one of the stacks.
    //
    // There are now two options:
    // - we ran out of things in the "target" stack - in which case, they are common enough to not
    //   need any resolution - just give back the fixed name
    // - we have things left in the "target" stack - in which case we have found a common ancestor,
    //   or the target is a descendent; either way, just concat what is left (including the package
    //   if the package itself was different)

    //private string FindNameFromCommonAncestor(IType declaring, IType target, NameNormalizer normalizer)
    //{
    //    // trivial case; asking for self, or asking for immediate child
    //    if (ReferenceEquals(declaring, target) || ReferenceEquals(declaring, target.Parent))
    //    {
    //        if (target is DescriptorProto message) return Escape(normalizer.GetName(message));
    //        if (target is EnumDescriptorProto @enum) return Escape(normalizer.GetName(@enum));
    //        return null;
    //    }

    //    var origTarget = target;
    //    var xStack = new Stack<IType>();

    //    while (declaring != null)
    //    {
    //        xStack.Push(declaring);
    //        declaring = declaring.Parent;
    //    }
    //    var yStack = new Stack<IType>();

    //    while (target != null)
    //    {
    //        yStack.Push(target);
    //        target = target.Parent;
    //    }
    //    int lim = Math.Min(xStack.Count, yStack.Count);
    //    for (int i = 0; i < lim; i++)
    //    {
    //        declaring = xStack.Peek();
    //        target = yStack.Pop();
    //        if (!ReferenceEquals(target, declaring))
    //        {
    //            // special-case: if both are the package (file), and they have the same namespace: we're OK
    //            if (target is FileDescriptorProto targetFDP && declaring is FileDescriptorProto declaringFDP
    //                && normalizer.GetName(declaringFDP) == normalizer.GetName(targetFDP))
    //            {
    //                // that's fine, keep going
    //            }
    //            else
    //            {
    //                // put it back
    //                yStack.Push(target);
    //                break;
    //            }
    //        }
    //    }
    //    // if we used everything, then the target is an ancestor-or-self
    //    if (yStack.Count == 0)
    //    {
    //        target = origTarget;
    //        if (target is DescriptorProto message) return Escape(normalizer.GetName(message));
    //        if (target is EnumDescriptorProto @enum) return Escape(normalizer.GetName(@enum));
    //        return null;
    //    }

    //    var sb = new StringBuilder();
    //    while (yStack.Count != 0)
    //    {
    //        target = yStack.Pop();

    //        string nextName;
    //        if (target is FileDescriptorProto file) nextName = normalizer.GetName(file);
    //        else if (target is DescriptorProto message) nextName = normalizer.GetName(message);
    //        else if (target is EnumDescriptorProto @enum) nextName = normalizer.GetName(@enum);
    //        else return null;

    //        if (!string.IsNullOrWhiteSpace(nextName))
    //        {
    //            if (sb.Length == 0 && target is FileDescriptorProto) sb.Append("global::");
    //            else if (sb.Length != 0) sb.Append('.');
    //            sb.Append(Escape(nextName));
    //        }
    //    }
    //    return sb.ToString();
    //}

    private const string
        WellKnownTypeTimestamp = ".google.protobuf.Timestamp",
        WellKnownTypeDuration = ".google.protobuf.Duration",
        WellKnownTypeEmpty = ".google.protobuf.Empty";


    ///// <summary>
    ///// Emit code preceeding a set of service methods
    ///// </summary>
    //protected override void WriteServiceHeader(CodeGenGeneratorContext ctx, ServiceDescriptorProto service, ref object state)
    //{
    //    var name = ctx.NameNormalizer.GetName(service);
    //    if (ctx.EmitServicesFor(ServiceKinds.Grpc))
    //    {
    //        var tw = ctx.Write("[global::ProtoBuf.Grpc.Configuration.Service(@\"");
    //        tw.Write(service.FullyQualifiedName.TrimStart(ParserContext.Period));
    //        tw.WriteLine("\")]");
    //    }
    //    if (ctx.EmitServicesFor(ServiceKinds.Wcf))
    //    {
    //        var tw = ctx.Write("[global::System.ServiceModel.ServiceContract(Name = @\"");
    //        tw.Write(service.FullyQualifiedName.TrimStart(ParserContext.Period));
    //        tw.WriteLine("\")]");
    //    }
    //    WriteOptions(ctx, service.Options);
    //    ctx.WriteLine($"{GetAccess(GetAccess(service))} partial interface {Escape(name)}").WriteLine("{").Indent();
    //}

    ///// <summary>
    ///// Emit code following a set of service methods
    ///// </summary>
    //protected override void WriteServiceFooter(CodeGenGeneratorContext ctx, ServiceDescriptorProto service, ref object state)
    //{
    //    ctx.Outdent().WriteLine("}").WriteLine();
    //}

    ///// <summary>
    ///// Emit code representing a service method
    ///// </summary>
    //protected override void WriteServiceMethod(CodeGenGeneratorContext ctx, MethodDescriptorProto method, ref object state)
    //{
    //    var name = ctx.NameNormalizer.GetName(method);
    //    if (name != method.Name)
    //    {
    //        if (ctx.EmitServicesFor(ServiceKinds.Grpc))
    //        {
    //            ctx.WriteLine($@"[global::ProtoBuf.Grpc.Configuration.Operation(@""{method.Name}"")]");
    //        }
    //        if (ctx.EmitServicesFor(ServiceKinds.Wcf))
    //        {
    //            ctx.WriteLine($@"[global::System.ServiceModel.OperationContract(Name = @""{method.Name}"")]");
    //        }
    //    }
    //    WriteOptions(ctx, method.Options);

    //    string returnType, inputType;
    //    if (method.ServerStreaming)
    //    {
    //        returnType = "global::System.Collections.Generic.IAsyncEnumerable<" + GetTypeName(ctx, method.OutputType) + ">";
    //    }
    //    else
    //    {
    //        if (method.OutputType == WellKnownTypeEmpty)
    //        {
    //            returnType = "global::System.Threading.Tasks.ValueTask";
    //        }
    //        else
    //        {
    //            returnType = "global::System.Threading.Tasks.ValueTask<" + GetTypeName(ctx, method.OutputType) + ">";
    //        }
    //    }
    //    if (method.ClientStreaming)
    //    {
    //        inputType = "global::System.Collections.Generic.IAsyncEnumerable<" + GetTypeName(ctx, method.InputType) + ">"; 
    //    }
    //    else
    //    {
    //        if (method.InputType == WellKnownTypeEmpty)
    //        {
    //            inputType = null;
    //        }
    //        else
    //        {
    //            inputType = GetTypeName(ctx, method.InputType);
    //        }
    //    }

    //    var tw = ctx.Write($"{returnType} {Escape(name)}Async(");
    //    if (inputType != null)
    //    {
    //        tw.Write(inputType);
    //        tw.Write(method.ClientStreaming ? " values, " : " value, ");
    //    }
    //    tw.Write("global::ProtoBuf.Grpc.CallContext context");
    //    if (ctx.Supports(CSharp4))
    //    {
    //        tw.Write(" = default");
    //        if (!ctx.Supports(CSharp7_1))
    //        {
    //            tw.Write("(global::ProtoBuf.Grpc.CallContext)");
    //        }
    //    }
    //    tw.WriteLine(");");
    //}
}
